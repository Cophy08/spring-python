<?xml version="1.0" encoding="UTF-8"?>
<chapter id="objects">
	<title>The IoC container</title>

  	  <sidebar id="background-ioc">
	    <title>Background</title>
	
	    <para>In early 2004, Martin Fowler asked the readers of his site: when
	    talking about Inversion of Control: <quote><emphasis>the question is, what
	    aspect of control are [they] inverting?</emphasis></quote>. Fowler then
	    suggested renaming the principle (or at least giving it a more
	    self-explanatory name), and started to use the term <firstterm>Dependency
	    Injection</firstterm>. His article then continued to explain the ideas
	    underpinning the Inversion of Control (<acronym>IoC</acronym>) and
	    Dependency Injection (<acronym>DI</acronym>) principle.</para>
	
	    <para>If you need a decent insight into IoC and DI, please do refer to
	    said article : <ulink
	    url="http://martinfowler.com/articles/injection.html">http://martinfowler.com/articles/injection.html</ulink>.</para>
	  </sidebar>

	<para>Inversion Of Control (IoC), also known as
	<ulink url="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</ulink> is
	more of an architectural concept than a simple coding pattern.</para>

	<para>The idea is to decouple classes that depend on each other from inheriting
	other dependencies, and instead link them only at the interfacing level. This
	requires some sort of 3rd party software module to instantiate the concrete
	objects and "inject" them into the class that needs to call them.</para>
	
	<para>In Spring, there are certain classes whose instances form the backbone of your application and that
	are managed by the Spring IoC container. While Spring Java calls them
	<ulink url="http://en.wikipedia.org/wiki/Javabean">
	beans</ulink>, Spring Python and Spring for .NET call them <emphasis>objects</emphasis>.
	An object is simply a class instance that was instantiated, assembled and otherwise managed by a Spring
	IoC container instead of directly by your code; other than that, there is nothing special about a
	object. It is in all other respects one of probably many objects in your application. These
	objects, and the dependencies between them, are reflected in the configuration meta-data used
	by a container.</para>

	<para>The following diagram demonstrates a key Spring concept: building useful services on top of simple
	objects, configured through a container's set of blueprints, provides powerful services that are
	easier to maintain.</para>
	
	<para><mediaobject>
		<imageobject role="fo">
			<imagedata align="center" fileref="images/spring_triangle.png"
				format="PNG" scale="100%" width="100%"/>
		</imageobject>
		<imageobject role="html">
			<imagedata align="center" fileref="images/spring_triangle.png"
				format="PNG"/>
		</imageobject>
	</mediaobject></para>
	
	<para>This chapter provides the basics of Spring Python's IoC container by using examples
	with explanations. If you are familiar with Spring Java, then you may notice many similarities. Also,
	this document points out key differences. It shows how to define the objects, read them into a
	container, and then fetch the objects into your code.</para>
	
	<section id="objects-container">
		<title>Container</title>
		
		<para>A <emphasis>container</emphasis> is an object you create in your code that receives the definitions
		for objects from various sources. Your code goes to the container to request the object, and the
		container then does everything it needs to create an instance of that.</para>
		
		<para>Depending on the scope of the object definition, the container may create a new instance right
		there on the spot, or it may fetch a reference to a singleton instance that was created previously. If
		this is the first time a singleton-scoped object is requested, is created, stored, and then returned
		to you. For a prototype-scoped object, EVERY TIME you request an object, a new instance is created
		and NOT stored in the singleton cache.</para>
		
		<para>Containers depend on various <emphasis>object factories</emphasis> to do the heavy lifting
		of construction, and then itself will set any additional properties. There is also the possibility of
		additional behavior outside of object creation, which can be defined by extending the <classname>
		ObjectContainer</classname> class.</para>
		
		<para>The reason it is called a container is the idea that you are going to a central place to get your
		top level object. While it is also possible to get all your other objects, the core concept of
		<ulink url="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</ulink> is that below
		your top-most object, all the other dependencies have been injected and thus not require container access.
		That is what we mean when we say most of your code does NOT have to be Spring Python-aware.</para>
		
		<note>
			<title>Present vs. Future Object Containers</title>
			
			<para>Pay special note that there is no fixed requirement that a container actually be in a certain
			location. While the current solution is memory based, meaning your objects will be lost when your
			application shuts down, there is always the possibility of implementing some type of distributed,
			persistent object container. For example, it is within the realm of possibilities to implement
			a container that utilizes a	back-end database to "contain" things or utilizes some distributed memory
			cache spread between nodes.</para>
		</note>
		
		<section id="objects-container-objectcontainer">
			<title><classname>ObjectContainer</classname> vs. <classname>ApplicationContext</classname></title>
			
			<para>The name of the container is <classname>ObjectContainer</classname>. Its job is to pull
			in object meta-data from various sources, and then call on related object factories to create
			the objects. In fact, this container is capable of receiving object definitions from multiple
			sources, each of differing types such as XML, YAML, python code, and other future formats.</para> 
			
			<para>The following block of code shows an example of creating an object container, and then
			pulling an object out of the container.</para>
				
<programlisting><![CDATA[
from springpython.context import ApplicationContext
from springpython.config import XMLConfig

container = ApplicationContext(XMLConfig("app-context.xml"))
service = container.get_object("sampleService")
]]></programlisting>

			<para>The first thing you may notice is the fact that <classname>ApplicationContext</classname> was
			used instead of <classname>ObjectContainer</classname>. <classname>ApplicationContext</classname>
			is a subclass of <classname>ObjectContainer</classname>, and is typically used because it
			also performs additional pre- and post-creational logic.</para>
			
			<para>For example, any object that implements <interfacename>ApplicationContextAware</interfacename>
			will have an additional <methodname>app_context</methodname> attribute added, populated
			with a copy of the <classname>ApplicationContext</classname>. If your object's class extends
			<interfacename>ObjectPostProcessor</interfacename> and defines a
			<methodname>post_process_after_initialization</methodname>, the <interfacename>ApplicationContext</interfacename>
			will run that method against every instance of that object.</para>
			
		</section>

		<section id="objects-container-scope">
			<title>Scope of Objects / Lazy Initialization</title>

			<para>Another key duty of the container is to also manage the scope of objects. This means
			at what time that objects are created, where the instances are stored, how long before they are
			destroyed, and whether or not to create them when the container is first started up.</para>
			
			<para>Currently, two scopes are supported: SINGLETON and PROTOTYPE. A singleton-scoped object
			is cached in the container until application shutdown. A prototype-scoped object is never
			stored, thus requiring the object factory to create a new instance every time the object
			is requested from the container.</para>
			
			<para>The default policy for the container is to make everything SINGLETON and also eagerly fetch
			all objects when the container is first created. The scope for each object can be individually
			overriden. Also, the initialization of each object can be shifted to "lazy", whereby the object
			is not created until the first time it is fetched or referenced by another object.</para>
		</section>

	</section>
	
	<section id="objects-config">
		<title>Configuration</title>
		
		<para>Spring Python support different formats for defining objects. This project first began using
		the format defined by PyContainer, a now inactive project. The structure has been <ulink
		url="http://springpython.webfactional.com/schema/context/spring-python-pycontainer-context-1.0.xsd">
		captured into an XSD spec</ulink>. This format is primarily to support legacy apps that have
		already been built with Spring Python from its inception. There is no current priority to extend this
		format any further. Any new schema developments will be happening with <classname>XMLConfig</classname>
		and <classname>YamlConfig</classname>.</para>
		
		<para>In the spirit of <ulink url="http://www.springframework.org/javaconfig">Spring JavaConfig</ulink>
		and <ulink url="http://blog.springsource.com/2006/11/28/a-java-configuration-option-for-spring/">a blog
		posting</ulink> by Rod Johnson, another format has been defined. By extending
		<classname>PythonConfig</classname> and using the <methodname>@Object</methodname> python
		decorator, objects may be defined with pure python code in a centralized class.</para>
		
		<para>Due to limitations in the format of PyContainer, another <ulink
		url="http://springpython.webfactional.com/schema/context/spring-python-context-1.0.xsd">
		schema has been developed</ulink> called <classname>XMLConfig</classname> that more closely models
		the original Spring Java version. It has support for
		<link linkend="objects-config-xmlconfig-referenced">referenced objects</link> in many more places
		than PyContainer could handle, <link linkend="objects-config-xmlconfig-inner">inner
		objects</link> as well, various <link linkend="objects-config-xmlconfig-collections">collections</link>
		(lists, sets, frozen sets, tuples, dictionaries, and java-style props), and values.</para>

		<para>Spring Python also has a YAML-based parser called <classname>YamlConfig</classname>.</para>

		<para>Spring Python is ultimately about choice, which is why developers may extend the
		<classname>Config</classname> class to define their own object definition scanner. By plugging
		an instance of their scanner into <classname>ApplicationContext</classname>, definitions can
		result in instantiated objects.</para>
		
		<para>You may be wondering, amidst all these choices, which one to pick? Here are some suggestions
		based on your current solution space:</para>
		
		<itemizedlist>
			<listitem>			
				<para>New projects are encouraged to pick either <classname>PythonConfig</classname>,
				<classname>XMLConfig</classname>, or <classname>YamlConfig</classname>, based on your
				preference for pure python code, XML, or YAML.</para>
			</listitem>

			<listitem>			
				<para>Projects migrating from Spring Java can use <classname>SpringJavaConfig</classname>
				to ease transition, with a long term goal of migrating to <classname>XMLConfig</classname>,
				and perhaps finally <classname>PythonConfig</classname>.</para>
			</listitem>
		
			<listitem>
				<para>Apps already developed with Spring Python can use <classname>PyContainerConfig</classname>
				to keep running, but it is highly suggested you work towards <classname>XMLConfig</classname>.</para>			
			</listitem>

			<listitem>			
				<para>Projects currently using <classname>XMLConfig</classname> should be pretty easy to
				migrate to <classname>PythonConfig</classname>, since it is basically a one-to-one
				translation. The pure python configuration may turn out much more compact, especially if
				you are using <link linkend="objects-config-xmlconfig-collections">lists, sets, dictionaries, and props</link>.</para>

                                <para>It should also be relatively easy to migrate an <classname>XMLConfig</classname>-based
				configuration to <classname>YamlConfig</classname>. YAML tends to be more compact than XML,
				and some prefer not having to deal with the angle-bracket tax.</para>
			</listitem>
		</itemizedlist>
		
		<section id="objects-config-xmlconfig">
			<title><classname>XMLConfig</classname> - Spring Python's native XML format</title>

			<para><classname>XMLConfig</classname> is a class that scans object
			definitions stored in the new XML format defined for Spring Python. It looks
			very similar to Spring Java's 2.5 XSD spec, with some small changes.</para>
			
			<para>The following is a simple definition of objects. Later sections will show
			other options you have for wiring things together.</para>
			
<programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<objects xmlns="http://www.springframework.org/springpython/schema/objects"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/springpython/schema/objects
       		http://springpython.webfactional.com/schema/context/spring-python-context-1.0.xsd">
       		
	<object id="MovieLister" class="springpythontest.support.testSupportClasses.MovieLister" scope="prototype">
		<property name="finder" ref="MovieFinder"/>
		<property name="description"><ref object="SingletonString"/></property> 
	</object>
	
	<object id="MovieFinder" class="springpythontest.support.testSupportClasses.ColonMovieFinder" scope="singleton">
		<property name="filename"><value>support/movies1.txt</value></property>
	</object>
	
	<object id="SingletonString" class="springpythontest.support.testSupportClasses.StringHolder">
		<property name="str" value="There should only be one copy of this string"></property>
	</object>
</objects>
]]></programlisting>

			<para>The definitions stored in this file are fed to an <classname>XMLConfig</classname> instance
			which scans it, and then sends the meta-data to the <classname>ApplicationContext</classname>.
			Then, when the application code requests an object named <emphasis>MovieLister</emphasis> from the
			container, the container utilizes an object factory to create the object and return it.</para>
				
<programlisting><![CDATA[
from springpython.context import ApplicationContext
from springpython.config import XMLConfig

container = ApplicationContext(XMLConfig("app-context.xml"))
service = container.get_object("MovieLister")
]]></programlisting>
				
			<section id="objects-config-xmlconfig-referenced">
				<title>Referenced Objects</title>
				
				<para>A referenced object is where an object is needed, but instead of providing the
				definition right there, there is, instead, a name, referring to another object definition.</para>
				
				<para>Object definitions can refer to other objects in many places including: properties,
				constructor arguments, and objects embedded inside various
				<link linkend="objects-config-xmlconfig-collections">collections</link>. This is the
				way to break things down into smaller pieces. It also allows you more efficiently use memory and
				guarantee different objects are linked to the same backend object.</para>
				
				<para> The following fragment, pulled from the earlier example, shows two different properties
				referencing other objects. It demonstrates the two ways to refer to another object.</para>
				
<programlisting><![CDATA[
<object id="MovieLister" class="springpythontest.support.testSupportClasses.MovieLister" scope="prototype">
	<property name="finder" ref="MovieFinder"/>
	<property name="description"><ref object="SingletonString"/></property> 
</object>
]]></programlisting>

				<para>This means that instead of defining the object meant to be injected into the
				<methodname>description</methodname> property right there, the container must look elsewhere
				amongst its collection of object definitions for an object named <emphasis>SingletonString</emphasis>.</para>
				
				<note>
					<title>Referenced objects don't have to be in same configuration</title>
					
					<para>When a referenced object is encountered, finding its definition is referred back to the
					container. This means ANY of the input sources provided to the container can hold this definition,
					REGARDLESS of format.</para>
				</note>

				<note>
					<title>Spring Python ONLY supports global references</title>
					
					<para>While Spring Java has different levels of reference like <emphasis>parent</emphasis>,
					<emphasis>local</emphasis>, and <emphasis>global</emphasis>, Spring Python only supports
					<emphasis>global</emphasis> at this time.</para>
				</note>

				<para>In the following subsections, other types of object definitions are given. Each will also
				include information about embedding reference objects.</para>

			</section>
			
			<section id="objects-config-xmlconfig-inner">
				<title>Inner Objects</title>
				
				<para>Inner objects are objects defined inside another structure, and not at the root level
				of the XML document. The following shows an alternative configuration of a <classname>MovieLister</classname>
				where the <methodname>finder</methodname> uses a <emphasis>named inner object</emphasis>.</para>
				
<programlisting><![CDATA[
<object id="MovieLister3" class="springpythontest.support.testSupportClasses.MovieLister">
	<property name="finder">
		<object id="named" class="springpythontest.support.testSupportClasses.ColonMovieFinder">
			<property name="filename"><value>support/movies1.txt</value></property>
		</object>
	</property>
	<property name="description"><ref object="SingletonString"/></property>
</object>
]]></programlisting>

				<para>The <classname>ColonMovieFinder</classname> is indeed an inner object because it was defined
				inside the <emphasis>MovieLister3</emphasis> object. Objects defined at the top level have a
				container-level name that matches their <methodname>id</methodname> value. In this case, asking the
				container for a copy of <emphasis>MovieLister3</emphasis> will yield the top level object. However,
				named objects develop a path-like name based on where they are located. In this case, the inner
				<classname>ColonMovieFinder</classname> object will have a container-level name of
				<emphasis>MovieLister3.finder.named</emphasis>.</para>
				
				<para>Typically, neither your code nor other object definitions will have any need to reference
				<emphasis>MovieLister3.finder.named</emphasis>, but there may be cases where you need this. The
				<methodname>id</methodname> attribute of <classname>ColonMovieFinder</classname> can be left out
				(it is optional for inner objects) like this:</para>

<programlisting><![CDATA[
<object id="MovieLister2" class="springpythontest.support.testSupportClasses.MovieLister">
	<property name="finder">
		<object class="springpythontest.support.testSupportClasses.ColonMovieFinder">
			<property name="filename"><value>support/movies1.txt</value></property>
		</object>
	</property>
	<property name="description"><ref object="SingletonString"/></property>
</object>
]]></programlisting>
				
				<para>That is slightly more compact, and usually alright because you usually wouldn't access this object
				from anywhere. However, if you must, the name in this case is <emphasis>MovieLister2.finder.&lt;anonymous&gt;</emphasis>
				indicating an anonymous object.</para>
				
				<para>It is important to realize that inner objects have all the same privileges as top-level objects,
				meaning that they can also utilize <link linkend="objects-config-xmlconfig-referenced">reference objects</link>,
				<link linkend="objects-config-xmlconfig-collections">collections</link>, and inner objects themselves.</para>

			</section>
			
			<section id="objects-config-xmlconfig-collections">
				<title>Collections</title>
				
				<para>Spring Java supports many types of collections, including lists, sets, frozen sets, maps, tuples,
				and java-style properties. Spring Python supports these as well. The following configuration shows usage of
				<methodname>dict</methodname>, <methodname>list</methodname>, <methodname>props</methodname>, 
				<methodname>set</methodname>, <methodname>frozenset</methodname>, and <methodname>tuple</methodname>.</para>
				
<programlisting><![CDATA[
<object id="ValueHolder" class="springpythontest.support.testSupportClasses.ValueHolder">
	<constructor-arg><ref object="SingletonString"/></constructor-arg>
	<property name="some_dict">
		<dict>
			<entry><key><value>Hello</value></key><value>World</value></entry>
			<entry><key><value>Spring</value></key><value>Python</value></entry>
			<entry><key><value>holder</value></key><ref object="SingletonString"/></entry>
			<entry><key><value>another copy</value></key><ref object="SingletonString"/></entry>
		</dict>
	</property>
	<property name="some_list">
		<list>
			<value>Hello, world!</value>
			<ref object="SingletonString"/>
			<value>Spring Python</value>
		</list>
	</property>
	<property name="some_props">
		<props>
			<prop key="administrator">administrator@example.org</prop>
			<prop key="support">support@example.org</prop>
			<prop key="development">development@example.org</prop>
		</props>
	</property>
	<property name="some_set">
		<set>
			<value>Hello, world!</value>
			<ref object="SingletonString"/>
			<value>Spring Python</value>
		</set>
	</property>
	<property name="some_frozen_set">
		<frozenset>
			<value>Hello, world!</value>
			<ref object="SingletonString"/>
			<value>Spring Python</value>
		</frozenset>
	</property>
	<property name="some_tuple">
		<tuple>
			<value>Hello, world!</value>
			<ref object="SingletonString"/>
			<value>Spring Python</value>
		</tuple>
	</property>        
</object>
]]></programlisting>

				<itemizedlist>
					<listitem>
						<para><methodname>some_dict</methodname> is a python dictionary with four entries.</para>
					</listitem>
					<listitem>
						<para><methodname>some_list</methodname> is a python list with three entries.</para>
					</listitem>
					<listitem>
						<para><methodname>some_props</methodname> is also a python dictionary, containing three values.</para>
					</listitem>
					<listitem>
						<para><methodname>some_set</methodname> is an instance of python's
						<ulink url="http://www.python.org/doc/2.5.2/lib/types-set.html">mutable set</ulink>.</para>	
					</listitem>
					<listitem>
						<para><methodname>some_frozen_set</methodname> is an instance of python's
						<ulink url="http://www.python.org/doc/2.5.2/lib/types-set.html">frozen set</ulink>.</para>	
					</listitem>
					<listitem>
						<para><methodname>some_tuple</methodname> is a python tuple with three values.</para>
					</listitem>
				</itemizedlist>

				<note>
					<title>Java uses maps, Python uses dictionaries</title>
					
					<para>While java calls key-based structures <emphasis>maps</emphasis>, python calls them
					<emphasis>dictionaries</emphasis>. For this reason, the code fragment shows a "dict" entry, which
					is one-to-one with Spring Java's "map" definition.</para>
					
					<para>Java also has a <classname>Property</classname> class. Spring Python translates this into a python
					dictionary, making it more like an alternative to the configuring mechanism of
					<methodname>dict</methodname>.</para>
				</note>

			</section>
			
			<section id="objects-config-xmlconfig-constructors">
				<title>Constructors</title>
				
				<para>Python functions can have both positional and named arguments. Positional arguments get assembled
				into a tuple, and named arguments are assembled into a dictionary, before being passed to a function
				call. Spring Python takes advantage of that option when it comes to constructor calls. The following
				block of configuration data shows defining positional constructors.</para>
				
<programlisting><![CDATA[
<object id="AnotherSingletonString" class="springpythontest.support.testSupportClasses.StringHolder">
	<constructor-arg value="attributed value"/>
</object>

<object id="AThirdSingletonString" class="springpythontest.support.testSupportClasses.StringHolder">
	<constructor-arg><value>elemental value</value></constructor-arg>
</object>
]]></programlisting>

				<para>Spring Python will read these and then feed them to the class constructor in the same order
				as shown here.</para>
				
				<para>The following code configuration shows named constructor arguments. Spring Python
				converts these into keyword arguments, meaning it doesn't matter what order they are defined.</para> 

<programlisting><![CDATA[
<object id="MultiValueHolder" class="springpythontest.support.testSupportClasses.MultiValueHolder">
	<constructor-arg name="a"><value>alt a</value></constructor-arg>
	<constructor-arg name="b"><value>alt b</value></constructor-arg>
</object>

<object id="MultiValueHolder2" class="springpythontest.support.testSupportClasses.MultiValueHolder">
	<constructor-arg name="c"><value>alt c</value></constructor-arg>
	<constructor-arg name="b"><value>alt b</value></constructor-arg>
</object>
]]></programlisting>

				<para>This was copied from the code's test suite, where a test case is used to prove that order doesn't matter.
				It is important to note that positional constructor arguments are fed before named constructors,
				and that overriding a the same constructor parameter both by position and by name is not allowed by Python,
				and will in turn, generate a run-time error.</para>
				
				<para>It is also valuable to know that you can mix this up and use both.</para>

			</section>
			<section id="objects-config-xmlconfig-values">
				<title>Values</title>
				
				<para>For those of you that used Spring Python before <classname>XMLConfig</classname>, you may have noticed
				that expressing values isn't as succinct as the old format. A good example of the old PyContainer format
				would be:</para>
				
<programlisting><![CDATA[
<component id="user_details_service" class="springpython.security.userdetails.InMemoryUserDetailsService">
	<property name="user_dict">
		{
			"basichiblueuser"  : ("password1", ["ROLE_BASIC", "ASSIGNED_BLUE",   "LEVEL_HI"], True),
			"basichiorangeuser": ("password2", ["ROLE_BASIC", "ASSIGNED_ORANGE", "LEVEL_HI"], True),
			"otherhiblueuser"  : ("password3", ["ROLE_OTHER", "ASSIGNED_BLUE",   "LEVEL_HI"], True),
			"otherhiorangeuser": ("password4", ["ROLE_OTHER", "ASSIGNED_ORANGE", "LEVEL_HI"], True),
			"basicloblueuser"  : ("password5", ["ROLE_BASIC", "ASSIGNED_BLUE",   "LEVEL_LO"], True),
			"basicloorangeuser": ("password6", ["ROLE_BASIC", "ASSIGNED_ORANGE", "LEVEL_LO"], True),
			"otherloblueuser"  : ("password7", ["ROLE_OTHER", "ASSIGNED_BLUE",   "LEVEL_LO"], True),
			"otherloorangeuser": ("password8", ["ROLE_OTHER", "ASSIGNED_ORANGE", "LEVEL_LO"], True)
		}
	</property>
</component>
]]></programlisting>

				<note>
					<title>Why do I see <emphasis>components</emphasis> and not <emphasis>objects</emphasis>?</title>
					
					<para>In the beginning, PyContainer was used and it tagged the managed instances as <emphasis>
					components</emphasis>. After replacing PyContainer with a more sophisticated IoC container,
					the instances are now referred to as <emphasis>objects</emphasis>, however,	to maintain this legacy
					format, you will see <emphasis>component</emphasis> tags inside
					<classname>PyContainerConfig</classname>-based definitions.</para>
				</note>

				<para>While this is very succinct for expressing definitions using as much python as possible, that
				format makes it very hard to embed referenced objects and inner objects, since
				<classname>PyContainerConfig</classname> uses python's <methodname>eval</methodname> method to
				convert the material.</para>
				
				<para>The following configuration block shows how to configure the same thing for <classname>
				XMLConfig</classname>.</para>

<programlisting><![CDATA[
<object id="user_details_service" class="springpython.security.userdetails.InMemoryUserDetailsService">
	<property name="user_dict">
		<dict>
			<entry>
				<key><value>basichiblueuser</value></key>
				<value><tuple>
					<value>password1</value>
					<list><value>ROLE_BASIC</value><value>ASSIGNED_BLUE</value><value>LEVEL_HI</value></list>
					<value>True</value>
				</tuple></value>
			</entry>
			<entry>
				<key><value>basichiorangeuser</value></key>
				<value><tuple>
					<value>password2</value>
					<list><value>ROLE_BASIC</value><value>ASSIGNED_ORANGE</value><value>LEVEL_HI</value></list>
					<value>True</value>
				</tuple></value>
			</entry>
			<entry>
				<key><value>otherhiblueuser</value></key>
				<value><tuple>
					<value>password3</value>
					<list><value>ROLE_OTHER</value><value>ASSIGNED_BLUE</value><value>LEVEL_HI</value></list>
					<value>True</value>
				</tuple></value>
			</entry>
			<entry>
				<key><value>otherhiorangeuser</value></key>
				<value><tuple>
					<value>password4</value>
					<list><value>ROLE_OTHER</value><value>ASSIGNED_ORANGE</value><value>LEVEL_HI</value></list>
					<value>True</value>
				</tuple></value>
			</entry>
			<entry>
				<key><value>basicloblueuser</value></key>
				<value><tuple>
					<value>password5</value>
					<list><value>ROLE_BASIC</value><value>ASSIGNED_BLUE</value><value>LEVEL_LO</value></list>
					<value>True</value>
				</tuple></value>
			</entry>
			<entry>
				<key><value>basicloorangeuser</value></key>
				<value><tuple>
					<value>password6</value>
					<list><value>ROLE_BASIC</value><value>ASSIGNED_ORANGE</value><value>LEVEL_LO</value></list>
					<value>True</value>
				</tuple></value>
			</entry>
			<entry>
				<key><value>otherloblueuser</value></key>
				<value><tuple>
					<value>password7</value>
					<list><value>ROLE_OTHER</value><value>ASSIGNED_BLUE</value><value>LEVEL_LO</value></list>
					<value>True</value>
				</tuple></value>
			</entry>
			<entry>
				<key><value>otherloorangeuser</value></key>
				<value><tuple>
					<value>password8</value>
					<list><value>ROLE_OTHER</value><value>ASSIGNED_ORANGE</value><value>LEVEL_LO</value></list>
					<value>True</value>
				</tuple></value>
			</entry>
		</dict>
	</property>
</object>
]]></programlisting>

				<para>Of course this is more verbose than the previous block. However, it opens the door to
				having a much higher level of detail:</para>

<programlisting><![CDATA[
<object id="user_details_service2" class="springpython.security.userdetails.InMemoryUserDetailsService">
	<property name="user_dict">
		<list>
			<value>Hello, world!</value>
			<dict>
				<entry>
					<key><value>yes</value></key>
					<value>This is working</value>
				</entry>
				<entry>
					<key><value>no</value></key>
					<value>Maybe it's not?</value>
				</entry>
			</dict>
			<tuple>
				<value>Hello, from Spring Python!</value>
				<value>Spring Python</value>
				<dict>
					<entry>
						<key><value>yes</value></key>
						<value>This is working</value>
					</entry>
					<entry>
						<key><value>no</value></key>
						<value>Maybe it's not?</value>
					</entry>
				</dict>
				<list>
					<value>This is a list element inside a tuple.</value>
					<value>And so is this :)</value>
				</list>
			</tuple>
			<set>
				<value>1</value>
				<value>2</value>
				<value>1</value>
			</set>
			<frozenset>
				<value>a</value>
				<value>b</value>
				<value>a</value>
			</frozenset>
		</list>
	</property>
</object>
]]></programlisting>

			</section>
			
		</section>

		<section id="objects-config-yamlconfig">
			<title><classname>YamlConfig</classname> - Spring Python's YAML format</title>

			<para><classname>YamlConfig</classname> is a class that scans object
			definitions stored in a <ulink url="http://www.yaml.org">YAML 1.1 format</ulink> using the 
			<ulink url="http://pyyaml.org">PyYAML project</ulink>.</para>
			
			<para>The following is a simple definition of objects. Later sections will show
			other options you have for wiring things together.</para>
			
<programlisting><![CDATA[
objects:
    - object: MovieLister
      class: springpythontest.support.testSupportClasses.MovieLister
      scope: prototype
      properties:
          finder: {ref: MovieFinder}
          description: {ref: SingletonString}

    - object: MovieFinder
      class: springpythontest.support.testSupportClasses.ColonMovieFinder
      scope: singleton
      properties:
          filename: support/movies1.txt

    - object: SingletonString
      class: springpythontest.support.testSupportClasses.StringHolder
      properties:
          str: There should only be one copy of this string
]]></programlisting>

			<para>The definitions stored in this file are fed to an <classname>YamlConfig</classname> instance
			which scans it, and then sends the meta-data to the <classname>ApplicationContext</classname>.
			Then, when the application code requests an object named <emphasis>MovieLister</emphasis> from the
			container, the container utilizes an object factory to create the object and return it.</para>

				
<programlisting><![CDATA[
from springpython.context import ApplicationContext
from springpython.config import YamlConfig

container = ApplicationContext(YamlConfig("app-context.xml"))
service = container.get_object("MovieLister")
]]></programlisting>
				
			<section id="objects-config-yamlconfig-referenced">
				<title>Referenced Objects</title>
				
				<para>A referenced object is where an object is needed, but instead of providing the
				definition right there, there is, instead, a name, referring to another object definition.</para>
				
				<para>Object definitions can refer to other objects in many places including: properties,
				constructor arguments, and objects embedded inside various
				<link linkend="objects-config-yamlconfig-collections">collections</link>. This is the
				way to break things down into smaller pieces. It also allows you more efficiently use memory and
				guarantee different objects are linked to the same backend object.</para>
				
				<para> The following fragment, pulled from the earlier example, shows two different properties
				referencing other objects. It demonstrates the two ways to refer to another object.</para>

				
<programlisting><![CDATA[
object: MovieLister
class: springpythontest.support.testSupportClasses.MovieLister
scope: prototype
properties:
    finder: {ref: MovieFinder}
    description: {ref: SingletonString}
]]></programlisting>

				<para>This means that instead of defining the object meant to be injected into the
				<methodname>description</methodname> property right there, the container must look elsewhere
				amongst its collection of object definitions for an object named <emphasis>SingletonString</emphasis>.</para>
				
				<note>
					<title>Referenced objects don't have to be in same configuration</title>
					
					<para>When a referenced object is encountered, finding its definition is referred back to the
					container. This means ANY of the input sources provided to the container can hold this definition,
					REGARDLESS of format.</para>

				</note>

				<note>
					<title>Spring Python ONLY supports global references</title>
					
					<para>While Spring Java has different levels of reference like <emphasis>parent</emphasis>,
					<emphasis>local</emphasis>, and <emphasis>global</emphasis>, Spring Python only supports
					<emphasis>global</emphasis> at this time.</para>

				</note>

				<para>In the following subsections, other types of object definitions are given. Each will also
				include information about embedding reference objects.</para>

			</section>
			
			<section id="objects-config-yamlconfig-inner">
				<title>Inner Objects</title>
				
				<para>Inner objects are objects defined inside another structure, and not at the root level
				of the YAML document. The following shows an alternative configuration of a <classname>MovieLister</classname>

				where the <methodname>finder</methodname> uses a <emphasis>named inner object</emphasis>.</para>
				
<programlisting><![CDATA[
object: MovieLister3
class: springpythontest.support.testSupportClasses.MovieLister
properties:
    finder:
        object: named
        class: springpythontest.support.testSupportClasses.ColonMovieFinder
        properties:
            filename: support/movies1.txt
    description: {ref: SingletonString} 
]]></programlisting>

				<para>The <classname>ColonMovieFinder</classname> is indeed an inner object because it was defined
				inside the <emphasis>MovieLister3</emphasis> object. Objects defined at the top level have a
				container-level name that matches their <methodname>id</methodname> value. In this case, asking the
				container for a copy of <emphasis>MovieLister3</emphasis> will yield the top level object. However,
				named objects develop a path-like name based on where they are located. In this case, the inner
				<classname>ColonMovieFinder</classname> object will have a container-level name of
				<emphasis>MovieLister3.finder.named</emphasis>.</para>

				
				<para>Typically, neither your code nor other object definitions will have any need to reference
				<emphasis>MovieLister3.finder.named</emphasis>, but there may be cases where you need this. The
				value of the <methodname>object</methodname> key of <classname>ColonMovieFinder</classname> can
				be left out (it is optional for inner objects) like this:</para>

<programlisting><![CDATA[
object: MovieLister2
class: springpythontest.support.testSupportClasses.MovieLister
properties:
    finder:
        object:
        class: springpythontest.support.testSupportClasses.ColonMovieFinder
        properties:
            filename: support/movies1.txt
    description: {ref: SingletonString}
]]></programlisting>
				
				<para>That is slightly more compact, and usually alright because you usually wouldn't access this object
				from anywhere. However, if you must, the name in this case is <emphasis>MovieLister2.finder.&lt;anonymous&gt;</emphasis>
				indicating an anonymous object.</para>
				
				<para>It is important to realize that inner objects have all the same privileges as top-level objects,
				meaning that they can also utilize <link linkend="objects-config-yamlconfig-referenced">reference objects</link>,
				<link linkend="objects-config-yamlconfig-collections">collections</link>, and inner objects themselves.</para>

			</section>
			
			<section id="objects-config-yamlconfig-collections">
				<title>Collections</title>

				
				<para>Spring Java supports many types of collections, including lists, sets, frozen sets, maps, tuples,
				and java-style properties. Spring Python supports these as well. The following configuration shows usage of
				<methodname>dict</methodname>, <methodname>list</methodname>, 
				<methodname>set</methodname>, <methodname>frozenset</methodname>, and <methodname>tuple</methodname>.</para>
				
<programlisting><![CDATA[
      object: ValueHolder
      class: springpythontest.support.testSupportClasses.ValueHolder
      constructor-args:
          - {ref: SingletonString}
      properties:
          some_dict:
                Hello: World
                Spring: Python
                holder: {ref: SingletonString}
                another copy: {ref: SingletonString}
          some_list:
              - Hello, world!
              - ref: SingletonString
              - Spring Python
          some_props:
              administrator: administrator@example.org
              support: support@example.org
              development: development@example.org
          some_set:
              set:
                  - Hello, world!
                  - ref: SingletonString
                  - Spring Python
          some_frozen_set:
              frozenset:
                  - Hello, world!
                  - ref: SingletonString
                  - Spring Python
          some_tuple:
              tuple:
                  - Hello, world!
                  - ref: SingletonString
                  - Spring Python
]]></programlisting>

				<itemizedlist>
					<listitem>
						<para><methodname>some_dict</methodname> is a python dictionary with four entries.</para>
					</listitem>
					<listitem>
						<para><methodname>some_list</methodname> is a python list with three entries.</para>

					</listitem>
					<listitem>
						<para><methodname>some_props</methodname> is also a python dictionary, containing three values.</para>
					</listitem>
					<listitem>
						<para><methodname>some_set</methodname> is an instance of python's
						<ulink url="http://www.python.org/doc/2.5.2/lib/types-set.html">mutable set</ulink>.</para>	
					</listitem>

					<listitem>
						<para><methodname>some_frozen_set</methodname> is an instance of python's
						<ulink url="http://www.python.org/doc/2.5.2/lib/types-set.html">frozen set</ulink>.</para>	
					</listitem>
					<listitem>
						<para><methodname>some_tuple</methodname> is a python tuple with three values.</para>

					</listitem>
				</itemizedlist>

				<note>
					<title>Java uses maps, Python uses dictionaries</title>
					
					<para>While java calls key-based structures <emphasis>maps</emphasis>, python calls them
					<emphasis>dictionaries</emphasis>. For this reason, the code fragment shows a "dict" entry, which
					is one-to-one with Spring Java's "map" definition.</para>

					
					<para>Java also has a <classname>Property</classname> class. Since YAML already supports a key/value
					structure as-is, <classname>YamlConfig</classname> does not have a separate structural definition.</para>
				</note>

			</section>
			
			<section id="objects-config-yamlconfig-constructors">
				<title>Constructors</title>

				
				<para>Python functions can have both positional and named arguments. Positional arguments get assembled
				into a tuple, and named arguments are assembled into a dictionary, before being passed to a function
				call. Spring Python takes advantage of that option when it comes to constructor calls. The following
				block of configuration data shows defining positional constructors.</para>
				
<programlisting><![CDATA[
object: AnotherSingletonString
class: springpythontest.support.testSupportClasses.StringHolder
constructor-args:
    - position 1's constructor value
]]></programlisting>

				<para>Spring Python will read these and then feed them to the class constructor in the same order
				as shown here.</para>
				
				<para>The following code configuration shows named constructor arguments. Spring Python
				converts these into keyword arguments, meaning it doesn't matter what order they are defined.</para> 

<programlisting><![CDATA[
object: MultiValueHolder
class: springpythontest.support.testSupportClasses.MultiValueHolder
constructor-args:
    a: alt a
    b: alt b
]]></programlisting>

				<para>This was copied from the code's test suite, where a test case is used to prove that order doesn't matter.
				It is important to note that positional constructor arguments are fed before named constructors,
				and that overriding a the same constructor parameter both by position and by name is not allowed by Python,
				and will in turn, generate a run-time error.</para>

				
				<para>It is also valuable to know that you can mix this up and use both.</para>

			</section>

		</section>

		<section id="objects-config-object">
			<title><classname>PythonConfig</classname> and <methodname>@Object</methodname> -
			decorator-driven configuration</title>
			
			<para>By defining a class that extends <classname>PythonConfig</classname> and using the
			<methodname>@Object</methodname> decorator, you can wire your application using pure python code.</para>
				
<programlisting><![CDATA[
from springpython.config import PythonConfig
from springpython.config import Object
from springpython.context import scope

class MovieBasedApplicationContext(PythonConfig):
    def __init__(self):
        super(MovieBasedApplicationContext, self).__init__()
        
    @Object(scope.PROTOTYPE)
    def MovieLister(self):
        lister = MovieLister()
        lister.finder = self.MovieFinder()
        lister.description = self.SingletonString()
        self.logger.debug("Description = %s" % lister.description)
        return lister
    
    @Object(scope.SINGLETON)
    def MovieFinder(self):
        return ColonMovieFinder(filename="support/movies1.txt")
    
    @Object    # scope.SINGLETON is the default
    def SingletonString(self):
        return StringHolder("There should only be one copy of this string")
    
    def NotExposed(self):
        pass
]]></programlisting>

			<para>As part of this example, the method <methodname>NotExposed</methodname> is also shown.
			This indicates that using <methodname>get_object</methodname> won't fetch that method,
			since it isn't considered an object.</para>
			
			<para>By using pure python, you don't have to deal with any XML. If you look closely,
			you will notice that the container code below is only different in the line actually
			creating the container. Everything else is the same.</para>
				
<programlisting><![CDATA[
from springpython.context import ApplicationContext

container = ApplicationContext(MovieBasedApplicationContext())
service = container.get_object("MovieLister")
]]></programlisting>

		</section>
		
		<section id="objects-config-pycontainer">
			<title><classname>PyContainerConfig</classname> - Spring Python's original XML format</title>

			<para><classname>PyContainerConfig</classname> is a class that scans object
			definitions stored in the format defined by PyContainer, which was the original XML format used
			by Spring Python to define objects.</para>
			
			<para>An important thing to note is that PyContainer used the term <emphasis>component</emphasis>,
			while Spring Python uses <emphasis>object</emphasis>. In order to support this legacy format, 
			<emphasis>component</emphasis> will show up in <classname>PyContainerConfig</classname>-based
			configurations.</para>

			<note>
				<title>PyContainer's format is deprecated</title>
				
				<para>PyContainer's format and the original parser was useful for getting this project started.
				However, it has shown its age by not being easy to revise nor extend. So this format is being
				retired. This parser is solely provided to help sustain existing Spring Python apps until
				they can migrate to either the <link linkend="objects-config-xmlconfig">XMLConfig</link> or 
				the <link linkend="objects-config-yamlconfig">YamlConfig</link> format.</para>
			</note>
			
<programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<components xmlns="http://www.springframework.org/springpython/schema/pycontainer-components"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/springpython/schema/pycontainer-components
       		http://springpython.webfactional.com/schema/context/spring-python-pycontainer-context-1.0.xsd">

    <component id="MovieLister" class="springpythontest.support.testSupportClasses.MovieLister" scope="prototype">
	    <property name="finder" local="MovieFinder"/>
	    <property name="description" local="SingletonString"/>
	</component>

	<component id="MovieFinder" class="springpythontest.support.testSupportClasses.ColonMovieFinder" scope="singleton">
		<property name="filename">"support/movies1.txt"</property>
	</component>
    
    <component id="SingletonString" class="springpythontest.support.testSupportClasses.StringHolder">
    	<property name="str">"There should only be one copy of this string"</property>
    </component>
</components>
]]></programlisting>

			<para>The definitions stored in this file are fed in to a <classname>PyContainerConfig</classname>
			which scans it, and then sends the meta-data to the <classname>ApplicationContext</classname>.
			Then, when the application code requests an object named "MovieLister" from the container, the
			container utilizes an object factory to create an object and return it.</para>
				
<programlisting><![CDATA[
from springpython.context import ApplicationContext
from springpython.config import PyContainerConfig

container = ApplicationContext(PyContainerConfig("app-context.xml"))
service = container.get_object("MovieLister")
]]></programlisting>
				
		</section>

		<section id="objects-config-springjava">
			<title><classname>SpringJavaConfig</classname></title>

			<para>The <classname>SpringJavaConfig</classname> is a class that scans object
			definitions stored in the format defined by the Spring Framework's original java version.
			This makes it even easier to migrate parts of an existing Spring Java application onto
			the Python platform.</para>
			
			<note>
				<title>This is about configuring python objects NOT java objects</title>
				
				<para>It is important to point out that this has nothing to do with configuring
				java-backed beans from Spring Python, or somehow injecting java-backed beans
				magically into a python object. This is PURELY for configuring python-backed objects
				using a format that was originally designed for pure java beans.</para>
				
				<para>When ideas like "converting java to python" are mentioned, it is meant that
				re-writing certain parts of your app in python would require a similar IoC configuration,
				however, for the java and python parts to integrate, you must utilize interoperable
				solutions like web service or other <link linkend="remoting">remoting</link> technologies.</para>
			</note>
			
<programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

	<bean id="MovieLister" class="springpythontest.support.testSupportClasses.MovieLister" scope="prototype">
		<property name="finder" ref="MovieFinder"/>
		<property name="description"><ref bean="SingletonString"/></property>
	</bean>
	
	<bean id="MovieFinder" class="springpythontest.support.testSupportClasses.ColonMovieFinder" scope="singleton">
		<property name="filename"><value>support/movies1.txt</value></property>
	</bean>
	
	<bean id="SingletonString" class="springpythontest.support.testSupportClasses.StringHolder">
		<property name="str" value="There should only be one copy of this string"></property>
	</bean>
</beans>
]]></programlisting>

			<para>The definitions stored in this file are fed in to a <classname>SpringJavaConfig</classname>
			which scans it, and then sends the meta-data to the <classname>ApplicationContext</classname>.
			Then, when the application code requests an object named "MovieLister" from the container, the
			container utilizes an object factory to create an object and return it.</para>
				
<programlisting><![CDATA[
from springpython.context import ApplicationContext
from springpython.config import SpringJavaConfig

container = ApplicationContext(SpringJavaConfig("app-context.xml"))
service = container.get_object("MovieLister")
]]></programlisting>

			<para>Again, the only difference in your code is using <classname>SpringJavaConfig</classname> instead
			of <classname>PyContainerConfig</classname> on one line. Everything is the same, since it is all
			inside the <classname>ApplicationContext</classname>.</para>
			
			<note>
				<title>What parts of Spring Java configuration are supported?</title>
				
				<para>It is important to note that only spring-beans-2.5 has been tested at this point in time.
				It is possible that older versions of the XSD spec may also work.</para>
				
				<para>Spring Java's other names spaces, like <emphasis>tx</emphasis> and <emphasis>aop</emphasis>,
				probably DON'T work. They haven't been tested, and there is no special code that will utilize
				their feature set.</para>
				
				<para>How much of Spring Java will be supported? That is an open question, best discussed on
				<ulink url="http://forum.springframework.org/forumdisplay.php?f=45">Spring Python's community forum</ulink>.
				Basically, this is meant to ease current Java developers into Spring Python and/or provide
				a means to split up objects to support porting parts of your application into Python. There
				isn't any current intention of providing full blown support.</para>
			</note>
				
		</section>
		
		<section id="objects-config-mixed">
			<title>Mixing Configuration Modes</title>
			
			<para>Spring Python also supports providing object definitions from multiple sources, and
			allowing them to reference each other. This section shows the same app context, but split
			between two different sources.</para>
			
			<para>First, the XML file containing the key object that gets pulled:</para>
				
<programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<components xmlns="http://www.springframework.org/springpython/schema/pycontainer-components"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/springpython/schema/pycontainer-components
       		http://springpython.webfactional.com/schema/context/spring-python-pycontainer-context-1.0.xsd">

    <component id="MovieLister" class="springpythontest.support.testSupportClasses.MovieLister" scope="prototype">
	    <property name="finder" local="MovieFinder"/>
	    <property name="description" local="SingletonString"/>
	</component>

    <component id="SingletonString" class="springpythontest.support.testSupportClasses.StringHolder">
    	<property name="str">"There should only be one copy of this string"</property>
    </component>
</components>
]]></programlisting>

			<para>Notice that <emphasis>MovieLister</emphasis> is referencing
			<emphasis>MovieFinder</emphasis>, however that object is NOT defined in this location.
			The definition is found elsewhere:</para>

<programlisting><![CDATA[
class MixedApplicationContext(PythonConfig):
    def __init__(self):
        super(MixedApplicationContext, self).__init__()
        
    @Object(scope.SINGLETON)
    def MovieFinder(self):
        return ColonMovieFinder(filename="support/movies1.txt")
]]></programlisting>

			<note>
				<title>Object ref must match function name</title>
				
				<para>In this situation, an XML-based object is referencing python code by the name
				<emphasis>MovieFinder</emphasis>. It is of paramount importance that the python function
				have the same name as the referenced string.</para>
			</note>
			
			<para>With some simple code, this is all brought together when the container is created.</para>

<programlisting><![CDATA[
from springpython.context import ApplicationContext
from springpython.config import PyContainerConfig

container = ApplicationContext([MixedApplicationContext(),
                                PyContainerConfig("mixed-app-context.xml")])
movieLister = container.get_object("MovieLister")
]]></programlisting>

			<para>In this case, the XML-based object definition signals the container to look
			elsewhere for a copy of the MovieFinder object, and it succeeds by finding it in
			MixedApplicationContext.</para>
			
			<para>It is possible to switch things around, but it requires a slight change.</para>

<programlisting><![CDATA[
class MixedApplicationContext2(PythonConfig):
    def __init__(self):
        super(MixedApplicationContext2, self).__init__()
        
    @Object(scope.PROTOTYPE)
    def MovieLister(self):
        lister = MovieLister()
        lister.finder = self.app_context.get_object("MovieFinder")  # <-- only line that is different
        lister.description = self.SingletonString()
        self.logger.debug("Description = %s" % lister.description)
        return lister
    
    @Object    # scope.SINGLETON is the default
    def SingletonString(self):
        return StringHolder("There should only be one copy of this string")
]]></programlisting>

<programlisting><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<components xmlns="http://www.springframework.org/springpython/schema/pycontainer-components"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/springpython/schema/pycontainer-components
       		http://springpython.webfactional.com/schema/context/spring-python-pycontainer-context-1.0.xsd">

	<component id="MovieFinder" class="springpythontest.support.testSupportClasses.ColonMovieFinder" scope="singleton">
		<property name="filename">"support/movies1.txt"</property>
	</component>

</components>
]]></programlisting>

			<para>An XML-based object definition can refer to a <methodname>@Object</methodname>
			by name, however, the python code has to change its direct function call to a container
			lookup, otherwise it will fail.</para>
			
			<note>
				<title><classname>PythonConfig</classname> is <interfacename>ApplicationContextAware</interfacename></title>
				
				<para>In order to perform a <methodname>get_object</methodname>, the configuration needs a
				handle on the surrounding container. The base class <classname>PythonConfig</classname> provides this,
				so that you can easily look for any object (local or not) by using
				<methodname>self.app_context.get_object("name")</methodname></para>
			</note>
			
		</section>

	</section>
	
	<section id="objects-factories">
		<title>Object Factories</title>
		
		<para>Spring Python offers two types of factories, <classname>ReflectiveObjectFactory</classname>
		and <classname>PythonObjectFactory</classname>. These classes should rarely be used directly by
		the developer. They are instead used by the different types of configuration scanners.</para>
		
	</section>
	
	<section id="objects-testable-code">
	    <title>Testable Code</title>
	    
	    <para>One key value of using the IoC container is the how you can isolate parts of your code for better testing.
	    Imagine you had the following configuration:</para>
	    
<programlisting><![CDATA[
from springpython.config import *
from springpython.context import *

class MovieBasedApplicationContext(PythonConfig):
    def __init__(self):
        super(MovieBasedApplicationContext, self).__init__()
        
    @Object(scope.PROTOTYPE)
    def MovieLister(self):
        lister = MovieLister()
        lister.finder = self.MovieFinder()
        lister.description = self.SingletonString()
        self.logger.debug("Description = %s" % lister.description)
        return lister
    
    @Object(scope.SINGLETON)
    def MovieFinder(self):
        return ColonMovieFinder(filename="support/movies1.txt")
    
    @Object    # scope.SINGLETON is the default
    def SingletonString(self):
        return StringHolder("There should only be one copy of this string")
]]></programlisting>

        <para>To inject a test double for <classname>MovieFinder</classname>, your test code would only have to
        extend the class and override the <methodname>MovieFinder</methodname> method, and replace it with your
        stub or mock object. Now you have a nicely isolated instance of <classname>MovieLister</classname>.</para>

<programlisting><![CDATA[
class MyTestableAppContext(MovieBasedApplicationContext):
    def __init__(self):
        super(MyTestableAppContext, self).__init__()
        
    @Object
    def MovieFinder(self):
        return MovieFinderStub()
]]></programlisting>

	</section>

</chapter>

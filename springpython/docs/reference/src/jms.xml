<?xml version="1.0" encoding="UTF-8"?>
<chapter id="jms">
	<title>JMS messaging</title>
	
	<para>Java Message Service has been a well known means for decoupling the Java application's
    parts or to provide an integration service for otherwise disconnected Java applications.
    Thanks to JMS being purely an API, Spring Python offers a way for connecting to JMS providers and to participate
    in JMS messaging scenarios. JMS messages sent and received by a Spring Python powered
    application are no different than messages produced and consumed by Java applications,
    in fact, <emphasis>you can use Spring Python and JMS with no Java applications participating
    in message exchanging at all</emphasis>.</para>
	
	<para>The only JMS provider currently supported by Spring Python is IBM's WebSphere MQ, formerly known as MQSeries.</para>
    
    <para>Although Spring Python's JMS API is loosely based on Spring Java's, it's not a direct port
    and features a highly Pythonic look and feel.
    </para>
		
	<section id="jms-intro">
		<title>Introduction</title>
		<sidebar id="intro-syntax">
			<para>Througout the chapter pure Python code or YAML syntax is used
            to illustrate the support for JMS however it only represents the
            author's preferences and it's worth noting that you can use
            any of <link linkend="objects-config">Spring Python's formats</link> to configure the IoC container.
            Or you can use no IoC at all as it's a completely optional feature
            and one that's not strictly required by JMS.
            </para>
		</sidebar>
		<para>
        JMS messaging with Spring Python revolves around the idea of using
        a connection factory for obtaining a connection to a JMS provider and 
        <classname>springpython.jms.core.JmsTemplate</classname> as a means for
        sending and receiving messages. A JmsTemplate instance is tied
        to a connection factory however a single connection factory may be safely
        reused across multiple JmsTemplates.
        </para>
	</section>
    
	<section id="jms-dependencies">
		<title>Dependencies</title>
        <para>
            Support for JMS messaging with WebSphere MQ is built on top of
            the <ulink url="http://pymqi.sf.net">PyMQI</ulink> library which provides
            Python applications an access to WebSphere MQ queue managers. You need to separately install 
            PyMQI in order to use <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>.
        </para>
    </section>
    
	<section id="jms-quick-start">
		<title>Quick start</title>
        <para>
            Here's a few quick examples that will get you started with Spring
            Python and JMS. Both Python code and IoC with YAML syntax are shown.
            It's assumed there's a QM.1 queue manager running on host 192.168.1.121
            with its listener on port 1434 and connections are made through the
            server connection channel SVRCONN.1 to queues TEST.1 and TEST.2.
        </para>
        <section id="jms-quick-start-sending">
            <title>Sending</title>
            <para>First, let's send a message using nothing but pure Python code.</para>
<programlisting><![CDATA[
from springpython.jms.core import JmsTemplate
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN1.1"
host = "192.168.1.121"
listener_port = "1434"
queue1 = "TEST.1"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Every JmsTemplate uses a connection factory for actually communicating with a JMS provider.
jms_template = JmsTemplate(factory)

# And that's it, now we put the mandatory "Hello world" message on a queue.
jms_template.send("Hello world", queue1)

# We're not using an IoC so we must shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>

            <para>
                Now do the same but use an IoC container configured via <classname>springpython.config.YamlConfig</classname>.
                The configuration should be saved in a "jms-context.yml" file in the same directory
                the Python code using it will be saved in.
            </para>
<programlisting><![CDATA[
objects:
    - object: MyConnectionFactory
      class: springpython.jms.factory.WebSphereMQConnectionFactory
      properties:
          queue_manager: QM.1
          channel: SVRCONN.1
          host: 192.168.1.121
          listener_port: 1434
          
    - object: MyTemplate
      class: springpython.jms.core.JmsTemplate
      properties:
          factory: {ref: MyConnectionFactory}
          
    XXX: Doesn't work, ignore for now
    - object: MyQueue
      str: TEST.1
          
]]></programlisting>

            <para>
                And the Python code using the above IoC configuration.
            </para>
<programlisting><![CDATA[
from springpython.context import ApplicationContext
from springpython.config import YamlConfig

container = ApplicationContext(YamlConfig("./jms-context.yml"))

# Read the objects definitions from configuration.
queue1 = container.get_object("MyQueue")
jms_template = container.get_object("MyTemplate")

# Send the message.
jms_template.send("Hello world", queue1)

# The connection factory is now being managed by the IoC container which takes
# care of shutting down the factory. No need for manually destroying it.
]]></programlisting>
            <para>
                An obvious change is that the configuration is now kept separately
                from the implementation but another advantage is that the container
                will shut down the connection factory on itself as
                <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
                is a subclass of <classname>springpython.context.DisposableObject</classname>
                which means its .destroy method will be executed when the container
                will be shutting down.
            </para>
        </section>
        
        <section id="jms-quick-start-receiving">
            <title>Receiving</title>
            <para>The very same connection factory and JmsTemplate can be used for both sending and receiving.
            Examples below use the same definitions of objects as the sending examples do,
            they are repeated here for the sake of completness.</para>
<programlisting><![CDATA[
from springpython.jms.core import JmsTemplate
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"
queue1 = "TEST.1"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Every JmsTemplate uses a connection factory for actually communicating with a JMS provider.
jms_template = JmsTemplate(factory)

# Get a message off the queue. The call to receive will by default time out
# after 1000ms and raise springpython.jms.NoMessageAvailableException then.
jms_template.receive(queue1)

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>

            <para>
                And here's a complementary example showing the usage of <classname>springpython.config.YamlConfig</classname>.
                The configuration should be saved in a "jms-context.yml" file in the same directory
                the Python code using it will be saved in. Note that it's the same
                configuration that was used in the sending example.
            </para>
<programlisting><![CDATA[
objects:
    - object: MyConnectionFactory
      class: springpython.jms.factory.WebSphereMQConnectionFactory
      properties:
          queue_manager: QM.1
          channel: SVRCONN.1
          host: 192.168.1.121
          listener_port: 1434
          
    - object: MyTemplate
      class: springpython.jms.core.JmsTemplate
      properties:
          factory: {ref: MyConnectionFactory}
          
    XXX: Doesn't work, ignore for now
    - object: MyQueue
      str: TEST.1
]]></programlisting>

            <para>
                The Python code used for receiving a message from a queue configured
                using the <classname>springpython.config.YamlConfig</classname>.
            </para>
<programlisting><![CDATA[
from springpython.context import ApplicationContext
from springpython.config import YamlConfig

container = ApplicationContext(YamlConfig("./jms-context.yml"))

# Read the objects definitions from configuration
queue1 = container.get_object("MyQueue")
jms_template = container.get_object("MyTemplate")

# Get a message off the queue. The call to receive will by default time out
# after 1000ms and raise springpython.jms.NoMessageAvailableException then.
jms_template.receive(queue1)

# The connection factory is now being managed by the IoC container which takes
# care of shutting down the factory. No need for manually destroying it.
]]></programlisting>

        </section>
    </section>
    
    <section id="jms-connection-factories">
		<title>Connection factories</title>
        <section id="websphere-mq-connection-factory">
            <title>springpython.jms.factory.WebSphereMQConnectionFactory</title>
            <para> 
            
            <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
            implements access to WebSphere MQ JMS provider. Along with 
            <classname>springpython.jms.core.JmsTemplate</classname> it's the
            class you'll be most frequently using for sending and receiving
            of messages.
            </para>
            
            <para>
            Each <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
            object will hold at most one connection to WebSphere MQ, which will
            be lazily established when it'll be actually needed, e.g. when a message
            will need to be put on a queue for the first time. The connection
            will always be started in WebSphere MQ's client mode, there's no support
            for connecting in the bindings mode.
            </para>
            
            <para>
            Like all Spring Python's classes <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
            can be configured using pure Python or you can use Spring Python's IoC to separate your
            business code from configuration. Using IoC has an added benefit of taking care
            of destroying any open queues and closing the connection when the
            IoC shuts down - we'll get to it in a moment.
            </para>

            <para>
            <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
            provides several options that let you customize its behaviour
            and apart from the obvious ones which you
            must provide (like, the queue manager's host) all other options have
            sensible defaults which you'll rarely need to change, if at all.
            </para>
            
            <para>
            Here's a full initializer method reproduced for convenience
            and the explanation of default values used:
            </para>

<programlisting><![CDATA[
    def __init__(self, queue_manager=None, channel=None, host=None, listener_port=None,
            cache_open_send_queues=True, cache_open_receive_queues=True,
            use_shared_connections=True, local_queue_template="SYSTEM.DEFAULT.MODEL.QUEUE"):
]]></programlisting>

			<table id="jms-wmq-factory-init-options">

				<title><classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
                customizable options</title>
				
				<tgroup cols="2">
				
					<tbody>
						<row>
							<entry>queue_manager</entry>
							<entry>
                                <para>default: None</para>
                                <para><emphasis>Must be set manually</emphasis></para>
                                <para>Name of the queue manager, e.g. EAI.QM.1</para>
                            </entry>
 						</row>
                        
						<row>
							<entry>channel</entry>
							<entry>
                                <para>default: None</para>
                                <para><emphasis>Must be set manually</emphasis></para>
                                <para>Name of a server connection (SVRCONN) channel
                                through which the connection will be established,
                                e.g. EAI.SVRCONN.1</para>
                            </entry>
 						</row>
                        
						<row>
							<entry>host</entry>
							<entry>
                                <para>default: None</para>
                                <para><emphasis>Must be set manually</emphasis></para>
                                <para>Host name or IP on which the queue manager is
                                running, e.g. 192.168.1.103</para>
                            </entry>
 						</row>
                        
						<row>
							<entry>listener_port</entry>
							<entry>
                                <para>default: None</para>
                                <para><emphasis>Must be set manually</emphasis></para>
                                <para>Port on which the queue manager's listener is
                                accepting TCP connections, e.g. 1434</para>
                            </entry>
 						</row>
                        
						<row>
							<entry>cache_open_send_queues</entry>
							<entry>
                                <para>default: True</para>
                                <para></para>
                                <para>
                                    By default, 
                                    <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
                                    will keep references to open queues in a cache
                                    for later re-use. This speeds-up most operations
                                    as there's usually no need for closing a queue
                                    if it's going to be used in subsequent
                                    calls to queue manager. At times however,
                                    it's prefered to close the queues as soon
                                    as possible and <emphasis>cache_open_send_queues</emphasis>
                                    controls whether queues open for putting
                                    the messages on are to be kept in the cache.
                                </para>
                            </entry>
 						</row>
                        
						<row>
							<entry>cache_open_receive_queues</entry>
							<entry>
                                <para>default: True</para>
                                <para></para>
                                <para>This setting controls
                                whether queues open for receving of messages
                                should be kept in a cache. If set to
                                <emphasis>False</emphasis>, they will be
                                closed after the call to get a message off the
                                queue will have finished.
                                </para>
                            </entry>
 						</row>
                        
						<row>
							<entry>use_shared_connections</entry>
							<entry>
                                <para>default: True</para>
                                <para></para>
                                <para>A single
                                <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
                                object may be shared between multiple threads
                                to provide better performance. This setting allows
                                for marking the underlying connection to a
                                queue manager as a non-shareable and makes sure
                                that only one thread will be able to use it,
                                any call to the factory from a thread that
                                didn't open the connection will result
                                in a <classname>springpython.jms.JMSException</classname>
                                being raised. The setting should only be used when connecting to queue managers
                                running on z/OS systems as it otherwise can
                                hurt the performance of multi-threaded applications.
                                It has no impact on performance of single-threaded applications.
                                </para>
                            </entry>
 						</row>
                        
						<row>
							<entry>dynamic_queue_template</entry>
							<entry>
                                <para>default: SYSTEM.DEFAULT.MODEL.QUEUE</para>
                                <para></para>
                                <para>
                                The name of a model queue basing on which
                                the dynamic queues will be created. It is usually
                                desirable to override the default value as,
                                unless customized,
                                SYSTEM.DEFAULT.MODEL.QUEUE is a non-shared
                                (NOSHARE in MQ speak) queue and doesn't allow
                                for opening the dynamic queues for both sending
                                and receiving.
                                </para>
                            </entry>
 						</row>
 					</tbody>
 				</tgroup>
 			</table>
            
            <para>
                Here's an example of programatically creating a
                <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
                object:
            </para>
<programlisting><![CDATA[
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"

factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# ... use factory here.

# Always destroy the factory when not using an IoC container.
factory.destroy()
]]></programlisting>

            <para>
                An example of using YamlConfig for configuring
                <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
                inside of an IoC container.
            </para>
<programlisting><![CDATA[
objects:
    - object: MyConnectionFactory
      class: springpython.jms.factory.WebSphereMQConnectionFactory
      properties:
          queue_manager: QM.1
          channel: SVRCONN.1
          host: 192.168.1.121
          listener_port: 1434
]]></programlisting>

            <para>
                All cached queues will not be closed by a factory until after
                its .destroy will have been called which will happen automatically
                if you're using an IoC container. If the factory is configured
                programatically in Python you must call .destroy yourself in your
                code. A call to .destroy also closes the factory's connection
                to a queue manager.
            </para>
            
            <para>
                <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
                objects are thread-safe and may be shared between multiple threads
                if the queue manager supports sharing a single connection
                which is the case on all platforms except for z/OS.
            </para>
            
            <note>
                <title>For the curious one</title>
                <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
                and 
                <classname>springpython.jms.factory.MQRFH2JMS</classname>
                wrap the WebSphere MQ's native MQRFH2 wire-level format in a set of Python classes
                and hide any intricate details of communicating with queue managers.
                From the programmer's viewpoint, <classname>springpython.jms.factory.MQRFH2JMS</classname>
                is irrelevant, however it might be of interest to anyone willing
                to improve or expand Spring Python's JMS support.
            </note>
            
            
        </section>
    </section>
    
    <section id="jms-jms-template">
        <title>springpython.jms.core.JmsTemplate</title>
        
        <para>
            JmsTemplate is the class to use for sending and receiving JMS messages.
            A template must be associated with a connection factory and once
            configured, may be used for communicating in both directions. It's
            up to you to decide whether in your circumstances it makes sense
            to reuse a single template for all communications, have a single
            template for each queue involved or perhaps use separate, dedicated,
            templates, one for sending and one for receiving. Note however,
            <emphasis>that <classname>springpython.jms.core.JmsTemplate</classname>
            instances are not guaranteed to be thread-safe</emphasis> and no
            attempt has been made to make them be so.
        </para>
        
        <para>
            Remember that factories postpone connecting to a queue manager
            and creating a JmsTemplate instance doesn't necessarily mean
            there will be no connection errors when it will be first time used
            for sending or receiving.
        </para>
        
            <para>
                Here's how <classname>springpython.jms.core.JmsTemplate</classname>
                may be instantiated using Python code:
            </para>
<programlisting><![CDATA[
from springpython.jms.core import JmsTemplate
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN1.1"
host = "192.168.1.121"
listener_port = "1434"

factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)
jms_template = JmsTemplate(factory)

# Always destroy the factory when not using IoC
factory.destroy()
]]></programlisting>

            <para>
                An example of using YamlConfig to configure a JmsTemplate
            </para>
<programlisting><![CDATA[
objects:
    - object: MyConnectionFactory
      class: springpython.jms.factory.WebSphereMQConnectionFactory
      properties:
          queue_manager: QM.1
          channel: SVRCONN.1
          host: 192.168.1.121
          listener_port: 1434
          
    - object: jms_template
      class: springpython.jms.core.JmsTemplate
      properties:
          factory: MyConnectionFactory
]]></programlisting>

            <para>
            JmsTemplate allows for a number of options to customize its
            behaviour. The only options required to set manually is
            the <emphasis>factory</emphasis> parameter. Except for factory,
            all the parameters may be overriden by individual calls to sending
            or receiving of messages.
            </para>
<programlisting><![CDATA[
    def __init__(self, factory=None, delivery_persistent=None,
            priority=None, time_to_live=None, message_converter=None, 
            default_destination=None):
]]></programlisting>

			<table id="jms-wmq-jms-template-init-options">

				<title><classname>springpython.jms.core.JmsTemplate</classname>
                customizable options</title>
				
				<tgroup cols="2">
				
					<tbody>
						<row>
							<entry>factory</entry>
							<entry>
                                <para>default: None</para>
                                <para><emphasis>Must be set manually</emphasis></para>
                                <para>A JMS connection factory associated
                                with this JmsTemplate.</para>
                            </entry>
                        </row>
                        <row>
							<entry>delivery_persistent</entry>
							<entry>
                                <para>default: None</para>
                                <para>Tells whether messagas sent to a JMS
                                provider are by default persistent. If not set,
                                the persistency of messages is controlled
                                on a per messages basis (and defaults to
                                a persistent delivery).</para>
                            </entry>
                        </row>
                        <row>
							<entry>priority</entry>
							<entry>
                                <para>default: None</para>
                                <para>Messages sent to the provider may
                                be of different priority, usually on a scale
                                from 1 to 9. The setting controls the default
                                priority of all messages sent by this JmsTemplate,
                                unless overridden by individual messages.
                                A JMS provider will set the default priority
                                if no value is given here or when sending
                                the individual messages.
                                </para>
                            </entry>
                        </row>
                        <row>
							<entry>time_to_live</entry>
							<entry>
                                <para>default: None</para>
                                <para>
                                JMS allows for expiry of messages after a certain
                                time <emphasis>expressed in milliseconds</emphasis>.
                                The time to live of a message may be set here
                                and it will be applied to all messages sent
                                or can be set per each message sent. If no value
                                is provided here and when sending the message
                                to a destination, the message expiry time
                                is left to the discretion of a JMS provider.
                                </para>
                            </entry>
                        </row>
                        <row>
							<entry>message_converter</entry>
							<entry>
                                <para>default: None</para>
                                <para>It is sometimes desirable to not have to
                                deal with raw messages taken from or sent to
                                JMS provider from within a JmsTemplate object,
                                it may make more sense to delegate
                                converting the objects from and to JMS representation
                                to an external helper class. A message converter
                                is an object that helps decoupling the domain
                                objects from the fact that JMS is the transportation
                                layer used for communicating.  A single converter
                                may be used for converting the incoming
                                as well as outgoing messages.
                                See the <link linkend="jms-jms-template-message-converters">section
                                on message converters</link> for more details
                                and code examples. Setting the message converter
                                here will take precedence over setting it on
                                a per-message basis.
                                </para>
                            </entry>
                        </row>
                        <row>
							<entry>default_destination</entry>
							<entry>
                                <para>default: None</para>
                                <para>If all or most of the messages are sent to
                                or received from the same JMS destination,
                                it's usually useful to configure the destination's
                                name here and have it used in any subsequent
                                calls to a JMS provider. Note that
                                <emphasis>the value given is used as a
                                default destination for both sending and
                                receiving of messages</emphasis>.
                                </para>
                            </entry>
 						</row>
 					</tbody>
 				</tgroup>
 			</table>

        
        <section id="jms-template-sending">
            <title>Sending</title>
            
            <para>
            The basic approach is to send ASCII strings or unicode objects,
            which must allow for encoding into UTF-8.
            </para>
<programlisting><![CDATA[
# -*- coding: utf-8 -*-

from springpython.jms.core import JmsTemplate
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"
queue1 = "TEST.1"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Every JmsTemplate uses a connection factory for actually communicating with a JMS provider.
jms_template = JmsTemplate(factory)
jms_template.default_destination = queue1

# Send some ASCII
jms_template.send("Hi, Spring Python here")

# Send unicode
jms_template.send(u"Cześć, z tej strony Spring Python")

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>

        <para>
        Note that in an example above the message's destination has been taken
        from JmsTemplate. We can also specify it on send time or we can
        combine both approaches, like here:
        </para>
<programlisting><![CDATA[
# -*- coding: utf-8 -*-

from springpython.jms.core import JmsTemplate
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"
queue1 = "TEST.1"
queue2 = "TEST.2"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Every JmsTemplate uses a connection factory for actually communicating with a JMS provider.
jms_template = JmsTemplate(factory)
jms_template.default_destination = queue1

# Send some ASCII to one queue
jms_template.send("Hi, Spring Python here")

# Send unicode to another queue
jms_template.send(u"Cześć, z tej strony Spring Python", queue2)

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>

        <para>
        Sending is not limited to strings or unicode objects though. You can customize
        a lot of message's properties by sending a
        <link linkend="jms-text-message">springpython.jms.core.TextMessage</link> instead.
        The following example shows how a custom message ID and reply to destination
        can be specified for an outgoing message.
        </para>
<programlisting><![CDATA[
# stdlib
from uuid import uuid4

# Spring Python
from springpython.jms.core import JmsTemplate, TextMessage
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"
queue1 = "TEST.1"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Every JmsTemplate uses a connection factory for actually communicating with a JMS provider.
jms_template = JmsTemplate(factory)
jms_template.default_destination = queue1

# Generate the correlation ID
jms_correlation_id = uuid4().hex

message = TextMessage("Hi, Spring Python here")
message.jms_correlation_id = jms_correlation_id
message.jms_reply_to = "REPLY.TO.QUEUE"

# Send the message
jms_template.send(message)

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>

        <para>
        Using TextMessage instances instead of plain strings or unicode objects
        is also recommended when you're interested in values a JMS provider has
        given to JMS properties of a message after the message had been sent.
        Here you can see the values which were assigned automatically
        by the provider to jms_timestamp and jms_message_id properties.
        </para>
<programlisting><![CDATA[
from springpython.jms.core import JmsTemplate, TextMessage
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"
queue1 = "TEST.1"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Every JmsTemplate uses a connection factory for actually communicating with a JMS provider.
jms_template = JmsTemplate(factory)
jms_template.default_destination = queue1

# Create a TextMessage instance.
message = TextMessage("Hi, Spring Python here")

# Send the message
jms_template.send(message)

print "jms_timestamp = %s" % message.jms_timestamp
print "jms_message_id = %s" % message.jms_message_id

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()

#
# Shows the following here:
#
# $ python jms_properties_overriding.py
# jms_timestamp = 1255885622380
# jms_message_id = ID:414d5120514d2e312020202020202020283cdb4a02220020
# $

]]></programlisting>

        <para>
        Take a look 
        <link linkend="jms-text-message">here</link> for more information
        about how to use TextMessages.
        </para>
            
        </section>
        
        <section id="jms-jms-template-receiving">
            <title>Receiving</title>
            
            <para>
            The same JmsInstance may be used for both sending and receiving
            of messages. When you receive messages you may optionally provide
            a timeout value in milliseconds after exceeding which a 
            <classname>springpython.jms.NoMessageAvailableException</classname>
            will be raised if no message will have been available for a given
            JMS destination. Default timeout is 1000 milliseconds.
            </para>
            
            <para>
            JmsTemplate may use a defualt JMS destination for each call to
            .receive or you can explicitly specify the destination's name
            when you receive messages.
            </para>
<programlisting><![CDATA[
from springpython.jms.core import JmsTemplate, TextMessage
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"
queue1 = "TEST.1"
queue2 = "TEST.2"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Every JmsTemplate uses a connection factory for actually communicating with a JMS provider.
jms_template = JmsTemplate(factory)
jms_template.default_destination = queue1

# Send a message to the first queue which is a default destination ..
jms_template.send("Hi there!")

# .. and now receive it.
print jms_template.receive()

# Now send a message to the second one ..
jms_template.send("Hi there again!", queue2)

# .. and now receive it ..
print jms_template.receive(queue2)

# .. try to receive a message again, this time requesting a timeout of 2 seconds.
print jms_template.receive(queue2, 2000)

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>
            
        </section>
        
        <section id="jms-jms-template-dynamic-queues">
            <title>Dynamic queues</title>
            
            <para>
                A dynamic queue is a usually short-lived object created on-demand
                by JMS applications, most often found in request-reply scenarios
                when there's no need for the response to be persistently stored.
                An application initiating the communication will create a dynamic
                temporary queue, send the request to the other side providing the name of
                the dynamic queue as a destination for the responses to be sent to
                and wait for a certain amount of time. 
                <emphasis>With Spring Python and WebSphere MQ,
                the requesting side must then explicitly close the dynamic queue
                </emphasis> regardless of whether the response will be received
                or if the request timeouts.
            </para>
            
            <para>
                The following example shows two JmsTemplate objects communicating
                via a dynamic queue and imitating an exchange of messages
                between two dispersed applications. You can observe than
                from the responding application's point of view a dynamic queue's
                name is like any other queue's name, it doesn't need to be - and indeed isn't -
                aware that it's responding to a dynamic queue and not to a 
                predefined one. For the requesting end a dynamic queue is also like
                a regular queue in that its name must be provided to the JmsTemplate's
                .receive method. Note that WebSphere MQ allows only non-persistent
                messages to be put on <emphasis>temporary</emphasis> dynamic
                queues which are the kind of dynamic queues you get by default
                with Spring Python.
            </para>
<programlisting><![CDATA[
from springpython.jms import DELIVERY_MODE_NON_PERSISTENT
from springpython.jms.core import JmsTemplate, TextMessage
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"

exchange_queue = "TEST.1"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

requesting_side = JmsTemplate(factory)
requesting_side.default_destination = exchange_queue

responding_side = JmsTemplate(factory)
responding_side.default_destination = exchange_queue

# Create a dynamic queue.
dyn_queue_name = requesting_side.open_dynamic_queue()

# Note that we wrap the whole conversation in a try/finally block as we must
# always close a WebSphere MQ dynamic queue.

try:
    # Create a request message.
    message = TextMessage("Hey, what's up on the other side?")
    
    # WebSphere MQ messages sent to dynamic temporary queues must not
    # be persistent.
    message.jms_delivery_mode = DELIVERY_MODE_NON_PERSISTENT
    
    # Tell the other side where to send responses.
    message.jms_reply_to = dyn_queue_name

    # Send the request
    requesting_side.send(message)

    # Receive the request ..
    request = responding_side.receive()
    
    # .. prepare the response ..
    response = TextMessage("A bit stormy today!")
    response.jms_delivery_mode = DELIVERY_MODE_NON_PERSISTENT
    
    # .. and send our response to a jms_reply_to destination which as we know
    # is a dynamic queue in this example.
    responding_side.send(response, request.jms_reply_to)
    
    # Receive the response. It's being read as usual, as from any other queue,
    # there's no special JmsTemplate's method for getting messages
    # off dynamic queues.
    print requesting_side.receive(dyn_queue_name)
    
finally:
    requesting_side.close_dynamic_queue(dyn_queue_name)

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>

        <para>
            It's worth mentioning again that you must close WebSphere MQ
            dynamic queues yourself as Spring Python won't do that for you - it's a slight
            deviation from how Java JMS works.
        </para>

        </section>
        
        <section id="jms-jms-template-message-converters">
            <title>Message converters</title>
            
            <para>
                It's quite possible that you'll like to separate the code responsible for
                core JMS communication with outside systems from the logic needed
                for converting your business domain's objects back and forth
                to strings needed for passing into JmsTemplate's methods. You
                may utilize your own converting classes for it or you can use
                the Spring Python's converters for such a work. A converter
                is a subclass of 
                <classname>springpython.jms.core.MessageConverter</classname>
                which must implement at least one of the 
                <emphasis>to_message</emphasis> or <emphasis>from_message</emphasis>
                methods. There's nothing magical about MessageConverter objects
                and they won't do any automatic convertions for you, they're just
                interfaces you can implement as you'll likely need some sort
                of separation between the objects you deal with and the JMS
                API.
            </para>
            
            <para>
                There's one difference you must take into account when using
                message converters - you don't use the standard send and
                receive methods but dedicated <emphasis>convert_and_send</emphasis>
                and <emphasis>receive_and_convert</emphasis> ones. Other than
                that, the JMS API and features are exactly the same.
            </para>
            
            <para>
                The code below shows a sample usage of MessageConverters. Note
                that you don't need to implement both
                <emphasis>to_message</emphasis> and <emphasis>from_message</emphasis>
                if that's not appropriate in your situation however it makes
                sense for the example to handle requests and responses using
                only one converter object. 
            </para>
<programlisting><![CDATA[
from springpython.jms.factory import WebSphereMQConnectionFactory
from springpython.jms.core import JmsTemplate, MessageConverter, TextMessage

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"

request_queue = "TEST.1"

# Note that it's the same queue so we're going to later receive the same invoice we sent.
response_queue = "TEST.1"

# One of the business domain's objects our application deals with.
class Invoice(object):
    def __init__(self, customer_account_id=None, month=None, amount=None):
        self.customer_account_id = customer_account_id
        self.month = month
        self.amount = amount
        
    def __str__(self):
        return "<%s at %s, customer_account_id=%s, month=%s, amount=%s>" % (
            self.__class__.__name__, hex(id(self)), self.customer_account_id,
            self.month, self.amount)

# Let's imagine the other side of a JMS link wants to receive and send CSV data.
class InvoiceConverter(MessageConverter):
    
    def to_message(self, invoice):
        """ Converts a business object to CSV.
        """
        text = ";".join((invoice.customer_account_id, invoice.month, invoice.amount))
        
        return TextMessage(text)
        
    def from_message(self, message):
        """ Produces a business object out of CSV data.
        """
        
        customer_account_id, month, amount = message.text.split(";")
        
        invoice = Invoice()
        invoice.customer_account_id = customer_account_id
        invoice.month = month
        invoice.amount = amount
        
        return invoice
        
# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Our JmsTemplate.
jms_template = JmsTemplate(factory)

# Here we tell the template to use our converter.
invoice_converter = InvoiceConverter()
jms_template.message_converter = invoice_converter

# See how we're now dealing only with business objects at the JmsTemplate level.

invoice = Invoice("00033010118", "200909", "136.32")
jms_template.convert_and_send(invoice, request_queue)

print jms_template.receive_and_convert(response_queue)

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>
            
        </section>
    </section>
    
    <section id="jms-text-message">
        <title>springpython.jms.core.TextMessage</title>
    </section>
    
    <section id="jms-exceptions">
        <title>Exceptions</title>
        <para>
            The base exception for all JMS-related issues is 
            <classname>springpython.jms..</classname>
        </para>
    </section>
    
    <section id="jms-logging-and-troubleshooting">
        <title>Logging and troubleshooting</title>
    </section>
	
</chapter>

<?xml version="1.0" encoding="UTF-8"?>
<chapter id="jms">
	<title>JMS messaging</title>
	
	<para>Java Message Service has been a well known means for decoupling the Java application's
    parts or to provide an integration service for otherwise disconnected Java applications.
    Thanks to JMS being purely an API, Spring Python offers a way for connecting to JMS providers and to participate
    in JMS messaging scenarios. JMS messages sent and received by a Spring Python powered
    application are no different than messages produced and consumed by Java applications,
    in fact, <emphasis>you can use Spring Python and JMS with no Java applications participating
    in message exchanging at all</emphasis>.</para>
	
    <para>Spring Python works as a JMS client, you still need a JMS provider,
        the server part, for message brokering.
        The only JMS provider currently supported by Spring Python is IBM's
        WebSphere MQ, formerly known as MQSeries.
    </para>
    
    <para>Although Spring Python's JMS API is loosely based on Spring Java's, it's not a direct port
    and features a highly Pythonic look and feel.
    </para>
    
	<para><mediaobject>
		<imageobject role="fo">
			<imagedata align="center" fileref="images/jms-map.png"
				format="PNG" scale="100%" width="100%"/>
		</imageobject>
		<imageobject role="html">
			<imagedata align="center" fileref="images/jms-map.png"
				format="PNG"/>
		</imageobject>
	</mediaobject></para>
		
	<section id="jms-intro">
		<title>Introduction</title>
		<sidebar id="jms-intro-syntax">
			<para>Througout the chapter pure Python code or YAML syntax is used
            to illustrate the support for JMS however it only represents the
            author's preferences and it's worth noting that you can use
            any of <link linkend="objects-config">Spring Python's formats</link> to configure the IoC container.
            Or you can use no IoC at all as it's a completely optional feature
            and one that's not strictly required by JMS.
            </para>
		</sidebar>
		<para>
        JMS messaging with Spring Python revolves around the idea of using
        a connection factory for obtaining a connection to a JMS provider and 
        <classname>springpython.jms.core.JmsTemplate</classname> as a means for
        sending and receiving messages. A JmsTemplate instance is tied
        to a connection factory however a single connection factory may be safely
        reused across multiple JmsTemplates.
        </para>
	</section>
    
	<section id="jms-dependencies">
		<title>Dependencies</title>
        <para>
            Support for JMS messaging with WebSphere MQ is built on top of
            the CPython-only <ulink url="http://pymqi.sf.net">PyMQI</ulink> library which provides
            Python applications an access to WebSphere MQ queue managers. You need to separately install 
            PyMQI in order to use <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>.
            PyMQI, in turn, needs a <emphasis>WebSphere MQ client</emphasis>, a runtime library
            which may be freely downloaded from IBM's site.
        </para>
    </section>
    
	<section id="jms-quick-start">
		<title>Quick start</title>
        <para>
            Here's a few quick examples that will get you started with Spring
            Python and JMS. Both Python code and IoC with YAML syntax are shown.
            It's assumed there's a QM.1 queue manager running on host 192.168.1.121
            with its listener on port 1434 and connections are made through the
            server connection channel SVRCONN.1 to queues TEST.1 and TEST.2.
        </para>
        <section id="jms-quick-start-sending">
            <title>Sending</title>
            <para>First, let's send a message using nothing but pure Python code.</para>
<programlisting><![CDATA[
from springpython.jms.core import JmsTemplate
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN1.1"
host = "192.168.1.121"
listener_port = "1434"
queue1 = "TEST.1"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Every JmsTemplate uses a connection factory for actually communicating with a JMS provider.
jms_template = JmsTemplate(factory)

# And that's it, now we put the mandatory "Hello world" message on a queue.
jms_template.send("Hello world", queue1)

# We're not using an IoC so we must shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>

            <para>
                Now do the same but use an IoC container configured via <classname>springpython.config.YamlConfig</classname>.
                The configuration should be saved in a "jms-context.yml" file in the same directory
                the Python code using it will be saved in.
            </para>
<programlisting><![CDATA[
objects:
    - object: MyConnectionFactory
      class: springpython.jms.factory.WebSphereMQConnectionFactory
      properties:
          queue_manager: QM.1
          channel: SVRCONN.1
          host: 192.168.1.121
          listener_port: 1434
          
    - object: MyTemplate
      class: springpython.jms.core.JmsTemplate
      properties:
          factory: {ref: MyConnectionFactory}
          
    - object: MyQueue
      str: TEST.1
          
]]></programlisting>

            <para>
                And the Python code using the above IoC configuration.
            </para>
<programlisting><![CDATA[
from springpython.context import ApplicationContext
from springpython.config import YamlConfig

container = ApplicationContext(YamlConfig("./jms-context.yml"))

# Read the objects definitions from configuration.
queue1 = container.get_object("MyQueue")
jms_template = container.get_object("MyTemplate")

# Send the message.
jms_template.send("Hello world", queue1)

# The connection factory is now being managed by the IoC container which takes
# care of shutting down the factory. No need for manually destroying it.
]]></programlisting>
            <para>
                An obvious change is that the configuration is now kept separately
                from the implementation but another advantage is that the container
                will shut down the connection factory on itself as
                <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
                is a subclass of <classname>springpython.context.DisposableObject</classname>
                which means its .destroy method will be executed when the container
                will be shutting down.
            </para>
        </section>
        
        <section id="jms-quick-start-receiving">
            <title>Receiving</title>
            <para>The very same connection factory and JmsTemplate can be used for both sending and receiving.
            Examples below use the same definitions of objects as the sending examples do,
            they are repeated here for the sake of completness.</para>
<programlisting><![CDATA[
from springpython.jms.core import JmsTemplate
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"
queue1 = "TEST.1"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Every JmsTemplate uses a connection factory for actually communicating with a JMS provider.
jms_template = JmsTemplate(factory)

# Get a message off the queue. The call to receive will by default time out
# after 1000ms and raise springpython.jms.NoMessageAvailableException then.
jms_template.receive(queue1)

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>

            <para>
                And here's a complementary example showing the usage of <classname>YamlConfig</classname>.
                The configuration should be saved in a "jms-context.yml" file in the same directory
                the Python code using it will be saved in. Note that it's the same
                configuration that was used in the sending example.
            </para>
<programlisting><![CDATA[
objects:
    - object: MyConnectionFactory
      class: springpython.jms.factory.WebSphereMQConnectionFactory
      properties:
          queue_manager: QM.1
          channel: SVRCONN.1
          host: 192.168.1.121
          listener_port: 1434
          
    - object: MyTemplate
      class: springpython.jms.core.JmsTemplate
      properties:
          factory: {ref: MyConnectionFactory}
          
    - object: MyQueue
      str: TEST.1
]]></programlisting>

            <para>
                The Python code used for receiving a message from a queue configured
                using the <classname>YamlConfig</classname>.
            </para>
<programlisting><![CDATA[
from springpython.context import ApplicationContext
from springpython.config import YamlConfig

container = ApplicationContext(YamlConfig("./jms-context.yml"))

# Read the objects definitions from configuration
queue1 = container.get_object("MyQueue")
jms_template = container.get_object("MyTemplate")

# Get a message off the queue. The call to receive will by default time out
# after 1000ms and raise springpython.jms.NoMessageAvailableException then.
jms_template.receive(queue1)

# The connection factory is now being managed by the IoC container which takes
# care of shutting down the factory. No need for manually destroying it.
]]></programlisting>

        </section>
    </section>
    
    <section id="jms-connection-factories">
		<title>Connection factories</title>
        <section id="websphere-mq-connection-factory">
            <title>springpython.jms.factory.WebSphereMQConnectionFactory</title>
            <para> 
            
            <classname>WebSphereMQConnectionFactory</classname>
            implements access to WebSphere MQ JMS provider. Along with 
            <classname>JmsTemplate</classname> it's the
            class you'll be most frequently using for sending and receiving
            of messages.
            </para>
            
            <para>
            Each <classname>WebSphereMQConnectionFactory</classname>
            object will hold at most one connection to WebSphere MQ, which will
            be lazily established when it'll be actually needed, e.g. when a message
            will need to be put on a queue for the first time. The connection
            will always be started in WebSphere MQ's client mode, there's no support
            for connecting in the bindings mode.
            </para>
            
            <para>
            Like all Spring Python's classes <classname>WebSphereMQConnectionFactory</classname>
            can be configured using pure Python or you can use Spring Python's IoC to separate your
            business code from configuration. Using IoC has an added benefit of taking care
            of destroying any open queues and closing the connection when the
            IoC shuts down - we'll get to it in a moment.
            </para>

            <para>
            <classname>WebSphereMQConnectionFactory</classname>
            provides several options that let you customize its behaviour
            and apart from the obvious ones which you
            must provide (like, the queue manager's host) all other options have
            sensible defaults which you'll rarely need to change, if at all.
            </para>
            
            <para>
            Here's a full initializer method reproduced for convenience
            and the explanation of default values used:
            </para>

<programlisting><![CDATA[
    def __init__(self, queue_manager=None, channel=None, host=None, listener_port=None,
            cache_open_send_queues=True, cache_open_receive_queues=True,
            use_shared_connections=True, local_queue_template="SYSTEM.DEFAULT.MODEL.QUEUE"):
]]></programlisting>

			<table id="jms-wmq-factory-init-options">

				<title><classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
                customizable options</title>
				
				<tgroup cols="2">
				
					<tbody>
						<row>
							<entry>queue_manager</entry>
							<entry>
                                <para>default: None</para>
                                <para><emphasis>Must be set manually</emphasis></para>
                                <para>Name of the queue manager, e.g. EAI.QM.1</para>
                            </entry>
 						</row>
                        
						<row>
							<entry>channel</entry>
							<entry>
                                <para>default: None</para>
                                <para><emphasis>Must be set manually</emphasis></para>
                                <para>Name of a server connection (SVRCONN) channel
                                through which the connection will be established,
                                e.g. EAI.SVRCONN.1</para>
                            </entry>
 						</row>
                        
						<row>
							<entry>host</entry>
							<entry>
                                <para>default: None</para>
                                <para><emphasis>Must be set manually</emphasis></para>
                                <para>Host name or IP on which the queue manager is
                                running, e.g. 192.168.1.103</para>
                            </entry>
 						</row>
                        
						<row>
							<entry>listener_port</entry>
							<entry>
                                <para>default: None</para>
                                <para><emphasis>Must be set manually</emphasis></para>
                                <para>Port on which the queue manager's listener is
                                accepting TCP connections, e.g. 1434</para>
                            </entry>
 						</row>
                        
						<row>
							<entry>cache_open_send_queues</entry>
							<entry>
                                <para>default: True</para>
                                <para></para>
                                <para>
                                    By default, 
                                    <classname>WebSphereMQConnectionFactory</classname>
                                    will keep references to open queues in a cache
                                    for later re-use. This speeds-up most operations
                                    as there's usually no need for closing a queue
                                    if it's going to be used in subsequent
                                    calls to queue manager. At times however,
                                    it's prefered to close the queues as soon
                                    as possible and <emphasis>cache_open_send_queues</emphasis>
                                    controls whether queues open for putting
                                    the messages on are to be kept in the cache.
                                </para>
                            </entry>
 						</row>
                        
						<row>
							<entry>cache_open_receive_queues</entry>
							<entry>
                                <para>default: True</para>
                                <para></para>
                                <para>This setting controls
                                whether queues open for receving of messages
                                should be kept in a cache. If set to
                                <emphasis>False</emphasis>, they will be
                                closed after the call to get a message off the
                                queue will have finished.
                                </para>
                            </entry>
 						</row>
                        
						<row>
							<entry>use_shared_connections</entry>
							<entry>
                                <para>default: True</para>
                                <para></para>
                                <para>A single
                                <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
                                object may be shared between multiple threads
                                to provide better performance. This setting allows
                                for marking the underlying connection to a
                                queue manager as a non-shareable and makes sure
                                that only one thread will be able to use it,
                                any call to the factory from a thread that
                                didn't open the connection will result
                                in a <classname>springpython.jms.JMSException</classname>
                                being raised. The setting should only set to False when connecting to queue managers
                                running on z/OS systems as it otherwise can
                                hurt the performance of multi-threaded applications.
                                It has no impact on performance of single-threaded applications.
                                </para>
                            </entry>
 						</row>
                        
						<row>
							<entry>dynamic_queue_template</entry>
							<entry>
                                <para>default: SYSTEM.DEFAULT.MODEL.QUEUE</para>
                                <para></para>
                                <para>
                                The name of a model queue basing on which
                                the dynamic queues will be created. It is usually
                                desirable to override the default value as,
                                unless customized,
                                SYSTEM.DEFAULT.MODEL.QUEUE is a non-shared
                                (NOSHARE in MQ speak) queue and doesn't allow
                                for opening the dynamic queues for both sending
                                and receiving.
                                </para>
                            </entry>
 						</row>
 					</tbody>
 				</tgroup>
 			</table>
            
            <para>
                Here's an example of programatically creating a
                <classname>WebSphereMQConnectionFactory</classname>
                object:
            </para>
<programlisting><![CDATA[
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"

factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# ... use factory here.

# Always destroy the factory when not using an IoC container.
factory.destroy()
]]></programlisting>

            <para>
                An example of using YamlConfig for configuring
                <classname>WebSphereMQConnectionFactory</classname>
                inside of an IoC container.
            </para>
<programlisting><![CDATA[
objects:
    - object: MyConnectionFactory
      class: springpython.jms.factory.WebSphereMQConnectionFactory
      properties:
          queue_manager: QM.1
          channel: SVRCONN.1
          host: 192.168.1.121
          listener_port: 1434
]]></programlisting>

            <para>
                All cached queues will not be closed by a factory until after
                its .destroy will have been called which will happen automatically
                if you're using an IoC container. If the factory is configured
                programatically in Python you must call .destroy yourself in your
                code. A call to .destroy also closes the factory's connection
                to a queue manager.
            </para>
            
            <para>
                <classname>WebSphereMQConnectionFactory</classname>
                objects are thread-safe and may be shared between multiple threads
                if the queue manager supports sharing a single connection
                which is the case on all platforms except for z/OS.
            </para>
            
            <note>
                <title>For the curious one</title>
                <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
                and 
                <classname>springpython.jms.factory.MQRFH2JMS</classname>
                wrap the WebSphere MQ's native MQRFH2 wire-level format in a set of Python classes
                and hide any intricate details of communicating with queue managers.
                From the programmer's viewpoint, <classname>MQRFH2JMS</classname>
                is irrelevant, however it might be of interest to anyone willing
                to improve or expand Spring Python's JMS support.
            </note>
            
            
        </section>
    </section>
    
    <section id="jms-jms-template">
        <title>springpython.jms.core.JmsTemplate</title>
        
        <para>
            JmsTemplate is the class to use for sending and receiving JMS messages.
            A template must be associated with a connection factory and once
            configured, may be used for communicating in both directions. It's
            up to you to decide whether in your circumstances it makes sense
            to reuse a single template for all communications, to have a single
            template for each queue involved or perhaps to use separate, dedicated,
            templates, one for sending and one for receiving. Note however,
            <emphasis>that <classname>JmsTemplate</classname>
            instances are not guaranteed to be thread-safe</emphasis> and no
            attempt has been made to make them be so.
        </para>
        
        <para>
            Remember that factories postpone connecting to a queue manager
            and creating a JmsTemplate instance doesn't necessarily mean
            there will be no connection errors when it will be first time used
            for sending or receiving.
        </para>
        
            <para>
                Here's how a <classname>JmsTemplate</classname>
                may be instantiated using Python code:
            </para>
<programlisting><![CDATA[
from springpython.jms.core import JmsTemplate
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN1.1"
host = "192.168.1.121"
listener_port = "1434"

factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)
jms_template = JmsTemplate(factory)

# Always destroy the factory when not using IoC
factory.destroy()
]]></programlisting>

            <para>
                An example of using YamlConfig to configure a JmsTemplate
            </para>
<programlisting><![CDATA[
objects:
    - object: MyConnectionFactory
      class: springpython.jms.factory.WebSphereMQConnectionFactory
      properties:
          queue_manager: QM.1
          channel: SVRCONN.1
          host: 192.168.1.121
          listener_port: 1434
          
    - object: jms_template
      class: springpython.jms.core.JmsTemplate
      properties:
          factory: {MyConnectionFactory}
]]></programlisting>

            <para>
            JmsTemplate allows for a number of options to customize its
            behaviour. The only options required to set manually is
            the <emphasis>factory</emphasis> parameter. Except for factory,
            all the parameters may be overriden by individual calls to sending
            or receiving of messages.
            </para>
<programlisting><![CDATA[
    def __init__(self, factory=None, delivery_persistent=None,
            priority=None, time_to_live=None, message_converter=None, 
            default_destination=None):
]]></programlisting>

			<table id="jms-wmq-jms-template-init-options">

				<title><classname>springpython.jms.core.JmsTemplate</classname>
                customizable options</title>
				
				<tgroup cols="2">
				
					<tbody>
						<row>
							<entry>factory</entry>
							<entry>
                                <para>default: None</para>
                                <para><emphasis>Must be set manually</emphasis></para>
                                <para>A JMS connection factory associated
                                with this JmsTemplate.</para>
                            </entry>
                        </row>
                        <row>
							<entry>delivery_persistent</entry>
							<entry>
                                <para>default: None</para>
                                <para>Tells whether messages sent to a JMS
                                provider are by default persistent. If not set,
                                the persistency of messages is controlled
                                on a per messages basis (and defaults to
                                a persistent delivery).</para>
                            </entry>
                        </row>
                        <row>
							<entry>priority</entry>
							<entry>
                                <para>default: None</para>
                                <para>Messages sent to the provider may
                                be of different priority, usually on a scale
                                from 1 to 9. The setting controls the default
                                priority of all messages sent by this JmsTemplate,
                                unless overridden by individual messages.
                                A JMS provider will set the default priority
                                if no value is given here or when sending
                                the individual messages.
                                </para>
                            </entry>
                        </row>
                        <row>
							<entry>time_to_live</entry>
							<entry>
                                <para>default: None</para>
                                <para>
                                JMS allows for expiry of messages after a certain
                                time <emphasis>expressed in milliseconds</emphasis>.
                                The time to live of a message may be set here
                                and it will be applied to all messages sent
                                or can be set per each message sent. If no value
                                is provided here and when sending the message
                                to a destination, the message expiry time
                                is left to the discretion of a JMS provider.
                                </para>
                            </entry>
                        </row>
                        <row>
							<entry>message_converter</entry>
							<entry>
                                <para>default: None</para>
                                <para>It is sometimes desirable to not have to
                                deal with raw messages taken from or sent to
                                JMS provider from within a JmsTemplate object,
                                it may make more sense to delegate
                                converting the objects from and to JMS representation
                                to an external helper class. A message converter
                                is an object that helps decoupling the domain
                                objects from the fact that JMS is the transportation
                                layer used for communicating.  A single converter
                                may be used for converting the incoming
                                as well as outgoing messages.
                                See the <link linkend="jms-jms-template-message-converters">section
                                on message converters</link> for more details
                                and code examples. Setting the message converter
                                here will take precedence over setting it on
                                a per-message basis.
                                </para>
                            </entry>
                        </row>
                        <row>
							<entry>default_destination</entry>
							<entry>
                                <para>default: None</para>
                                <para>If all or most of the messages are sent to
                                or received from the same JMS destination,
                                it's usually useful to configure the destination's
                                name here and have it used in any subsequent
                                calls to a JMS provider. Note that
                                <emphasis>the value given is used as a
                                default destination for both sending and
                                receiving of messages</emphasis>.
                                </para>
                            </entry>
 						</row>
 					</tbody>
 				</tgroup>
 			</table>

        
        <section id="jms-template-sending">
            <title>Sending</title>
            
            <para>
            The basic approach is to send ASCII strings or unicode objects,
            which must allow for encoding into UTF-8.
            </para>
<programlisting><![CDATA[
# -*- coding: utf-8 -*-

from springpython.jms.core import JmsTemplate
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"
queue1 = "TEST.1"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Every JmsTemplate uses a connection factory for actually communicating with a JMS provider.
jms_template = JmsTemplate(factory)
jms_template.default_destination = queue1

# Send some ASCII
jms_template.send("Hi, Spring Python here")

# Send unicode
jms_template.send(u"Cześć, z tej strony Spring Python")

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>

        <para>
        Note that in an example above the message's destination has been taken
        from JmsTemplate. We can also specify it on send time or we can
        combine both approaches, like here:
        </para>
<programlisting><![CDATA[
# -*- coding: utf-8 -*-

from springpython.jms.core import JmsTemplate
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"
queue1 = "TEST.1"
queue2 = "TEST.2"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Every JmsTemplate uses a connection factory for actually communicating with a JMS provider.
jms_template = JmsTemplate(factory)
jms_template.default_destination = queue1

# Send some ASCII to one queue
jms_template.send("Hi, Spring Python here")

# Send unicode to another queue
jms_template.send(u"Cześć, z tej strony Spring Python", queue2)

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>

        <para>
        Sending is not limited to strings or unicode objects though. You can customize
        a lot of message's properties by sending a
        <link linkend="jms-text-message">springpython.jms.core.TextMessage</link> instead.
        The following example shows how a custom message ID and reply to destination
        can be specified for an outgoing message.
        </para>
<programlisting><![CDATA[
# stdlib
from uuid import uuid4

# Spring Python
from springpython.jms.core import JmsTemplate, TextMessage
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"
queue1 = "TEST.1"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Every JmsTemplate uses a connection factory for actually communicating with a JMS provider.
jms_template = JmsTemplate(factory)
jms_template.default_destination = queue1

# Generate the correlation ID
jms_correlation_id = uuid4().hex

message = TextMessage("Hi, Spring Python here")
message.jms_correlation_id = jms_correlation_id
message.jms_reply_to = "REPLY.TO.QUEUE"

# Send the message
jms_template.send(message)

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>

        <para>
        Using TextMessage instances instead of plain strings or unicode objects
        is also recommended when you're interested in values a JMS provider has
        given to JMS properties of a message after the message had been sent.
        Here you can see the values which were assigned automatically
        by the provider to jms_timestamp and jms_message_id properties.
        </para>
<programlisting><![CDATA[
from springpython.jms.core import JmsTemplate, TextMessage
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"
queue1 = "TEST.1"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Every JmsTemplate uses a connection factory for actually communicating with a JMS provider.
jms_template = JmsTemplate(factory)
jms_template.default_destination = queue1

# Create a TextMessage instance.
message = TextMessage("Hi, Spring Python here")

# Send the message
jms_template.send(message)

print "jms_timestamp = %s" % message.jms_timestamp
print "jms_message_id = %s" % message.jms_message_id

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()

#
# Shows the following here:
#
# $ python jms_properties_overriding.py
# jms_timestamp = 1255885622380
# jms_message_id = ID:414d5120514d2e312020202020202020283cdb4a02220020
# $

]]></programlisting>

        <para>
        Take a look 
        <link linkend="jms-text-message">here</link> for more information
        about how to use TextMessages.
        </para>
            
        </section>
        
        <section id="jms-jms-template-receiving">
            <title>Receiving</title>
            
            <para>
            The same JmsTemplate instance may be used for both sending and receiving
            of messages. When you receive messages you may optionally provide
            a timeout value in milliseconds after exceeding which a 
            <classname>springpython.jms.NoMessageAvailableException</classname>
            will be raised if no message will have been available for a given
            JMS destination. Default timeout is 1000 milliseconds.
            </para>
            
            <para>
            JmsTemplate may use a default JMS destination for each call to
            .receive or you can explicitly specify the destination's name
            when you receive messages.
            </para>
<programlisting><![CDATA[
from springpython.jms.core import JmsTemplate, TextMessage
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"
queue1 = "TEST.1"
queue2 = "TEST.2"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Every JmsTemplate uses a connection factory for actually communicating with a JMS provider.
jms_template = JmsTemplate(factory)
jms_template.default_destination = queue1

# Send a message to the first queue which is a default destination ..
jms_template.send("Hi there!")

# .. and now receive it.
print jms_template.receive()

# Now send a message to the second one ..
jms_template.send("Hi there again!", queue2)

# .. and now receive it ..
print jms_template.receive(queue2)

# .. try to receive a message again, this time requesting a timeout of 2 seconds.
print jms_template.receive(queue2, 2000)

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>
            
        </section>
        
        <section id="jms-jms-template-dynamic-queues">
            <title>Dynamic queues</title>
            
            <para>
                A dynamic queue is a usually short-lived object created on-demand
                by JMS applications, most often found in request-reply scenarios
                when there's no need for the response to be persistently stored.
                An application initiating the communication will create a dynamic
                temporary queue, send the request to the other side providing the name of
                the dynamic queue as a destination for the responses to be sent to
                and wait for a certain amount of time. 
                <emphasis>With Spring Python and WebSphere MQ,
                the requesting side must then explicitly close the dynamic queue
                </emphasis> regardless of whether the response will be received
                or if the request timeouts.
            </para>
            
            <para>
                The following example shows two JmsTemplate objects communicating
                via a dynamic queue and imitating an exchange of messages
                between two dispersed applications. You can observe than
                from the responding application's point of view a dynamic queue's
                name is like any other queue's name, the application doesn't need to be - and indeed isn't -
                aware that it's responding to a dynamic queue and not to a 
                predefined one. For the requesting end a dynamic queue is also like
                a regular queue in that its name must be provided to the JmsTemplate's
                .receive method. Note that WebSphere MQ allows only non-persistent
                messages to be put on <emphasis>temporary</emphasis> dynamic
                queues which are the kind of dynamic queues you get by default
                with Spring Python.
            </para>
<programlisting><![CDATA[
from springpython.jms import DELIVERY_MODE_NON_PERSISTENT
from springpython.jms.core import JmsTemplate, TextMessage
from springpython.jms.factory import WebSphereMQConnectionFactory

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"

exchange_queue = "TEST.1"

# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

requesting_side = JmsTemplate(factory)
requesting_side.default_destination = exchange_queue

responding_side = JmsTemplate(factory)
responding_side.default_destination = exchange_queue

# Create a dynamic queue.
dyn_queue_name = requesting_side.open_dynamic_queue()

# Note that we wrap the whole conversation in a try/finally block as we must
# always close a WebSphere MQ dynamic queue.

try:
    # Create a request message.
    message = TextMessage("Hey, what's up on the other side?")
    
    # WebSphere MQ messages sent to dynamic temporary queues must not
    # be persistent.
    message.jms_delivery_mode = DELIVERY_MODE_NON_PERSISTENT
    
    # Tell the other side where to send responses.
    message.jms_reply_to = dyn_queue_name

    # Send the request
    requesting_side.send(message)

    # Receive the request ..
    request = responding_side.receive()
    
    # .. prepare the response ..
    response = TextMessage("A bit stormy today!")
    response.jms_delivery_mode = DELIVERY_MODE_NON_PERSISTENT
    
    # .. and send our response to a jms_reply_to destination which as we know
    # is a dynamic queue in this example.
    responding_side.send(response, request.jms_reply_to)
    
    # Receive the response. It's being read as usual, as from any other queue,
    # there's no special JmsTemplate's method for getting messages
    # off dynamic queues.
    print requesting_side.receive(dyn_queue_name)
    
finally:
    requesting_side.close_dynamic_queue(dyn_queue_name)

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>

        <para>
            It's worth mentioning again that you must close WebSphere MQ
            dynamic queues yourself as Spring Python won't do that for you - it's a slight
            deviation from how Java JMS works.
        </para>

        </section>
        
        <section id="jms-jms-template-message-converters">
            <title>Message converters</title>
            
            <para>
                It's quite possible that you'll like to separate the code responsible for
                core JMS communication with outside systems from the logic needed
                for converting your business domain's objects back and forth
                to strings needed for passing into JmsTemplate's methods. You
                may utilize your own converting classes for it or you can use
                the Spring Python's converters for such a work. A converter
                is a subclass of 
                <classname>springpython.jms.core.MessageConverter</classname>
                which must implement at least one of the 
                <emphasis>to_message</emphasis> or <emphasis>from_message</emphasis>
                methods. There's nothing magical about MessageConverter objects
                and they won't do any automatic convertions for you, they're just
                interfaces you can implement as you'll likely need some sort
                of separation between the objects you deal with and the JMS
                API.
            </para>
            
            <para>
                There's one difference you must take into account when using
                message converters - you don't use the standard send and
                receive methods but dedicated <emphasis>convert_and_send</emphasis>
                and <emphasis>receive_and_convert</emphasis> ones. Other than
                that, the JMS API and features are exactly the same.
            </para>
            
            <para>
                The code below shows a sample usage of MessageConverters. Note
                that you don't need to implement both
                <emphasis>to_message</emphasis> and <emphasis>from_message</emphasis>
                if that's not appropriate in your situation however it makes
                sense for the example below to handle requests and responses using
                only one converter object. 
            </para>
<programlisting><![CDATA[
from springpython.jms.factory import WebSphereMQConnectionFactory
from springpython.jms.core import JmsTemplate, MessageConverter, TextMessage

qm_name = "QM.1"
channel = "SVRCONN.1"
host = "192.168.1.121"
listener_port = "1434"

# Note that it's the same queue so we're going to later receive the same invoice we sent.
request_queue = response_queue = "TEST.1"

# One of the business domain's objects our application deals with.
class Invoice(object):
    def __init__(self, customer_account_id=None, month=None, amount=None):
        self.customer_account_id = customer_account_id
        self.month = month
        self.amount = amount
        
    def __str__(self):
        return "<%s at %s, customer_account_id=%s, month=%s, amount=%s>" % (
            self.__class__.__name__, hex(id(self)), self.customer_account_id,
            self.month, self.amount)

# Let's imagine the other side of a JMS link wants to receive and send CSV data.
class InvoiceConverter(MessageConverter):
    
    def to_message(self, invoice):
        """ Converts a business object to CSV.
        """
        text = ";".join((invoice.customer_account_id, invoice.month, invoice.amount))
        
        return TextMessage(text)
        
    def from_message(self, message):
        """ Produces a business object out of CSV data.
        """
        
        customer_account_id, month, amount = message.text.split(";")
        
        invoice = Invoice()
        invoice.customer_account_id = customer_account_id
        invoice.month = month
        invoice.amount = amount
        
        return invoice
        
# The connection factory we're going to use.
factory = WebSphereMQConnectionFactory(qm_name, channel, host, listener_port)

# Our JmsTemplate.
jms_template = JmsTemplate(factory)

# Here we tell the template to use our converter.
invoice_converter = InvoiceConverter()
jms_template.message_converter = invoice_converter

# See how we're now dealing only with business objects at the JmsTemplate level.

invoice = Invoice("00033010118", "200909", "136.32")
jms_template.convert_and_send(invoice, request_queue)

print jms_template.receive_and_convert(response_queue)

# We're not using an IoC so we need to shut down the connection factory ourselves.
factory.destroy()
]]></programlisting>
            
        </section>
    </section>
    
    <section id="jms-text-message">
        <title>springpython.jms.core.TextMessage</title>
        
        <para>
            TextMessage objects encapsulate the data being sent to or received
            from a JMS provider. Even if you use the plain 
            <emphasis>jms_template.send("Foobar")</emphasis> to send an ordinary
            text, there's still a TextMessage instance created automatically
            underneath for you.
        </para>
        
        <para>
            If all you need from JMS is simply to send and receive some text
            then you're not likely to be required to use TextMessages. However,
            if you have to set or read JMS attributes or you're interested in setting
            custom JMS properties then TextMessage is what you're looking for.
        </para>
        
        <para>
            In Spring Python there are no clumsy setters and getters as in Java
            JMS. If you need to set the property of a message, you just write
            it, like for instance
            <emphasis>message.jms_correlation_id = "1234567"</emphasis>.
            
            Here's the list of all TextMessage's attributes along with their
            explanation and usage notes.
            
			<table id="jms-jmstemplate-attributes">
            
				<title><classname>springpython.jms.core.TextMessage</classname>
                default attributes</title>
            
				<tgroup cols="2">
					<tbody>
						<row>
							<entry>text</entry>
							<entry>
                                The message contents, the actual business
                                payload carried by a message. May be both read
                                and written to. For messages sent to a JMS
                                provider it must be either a string or a unicode
                                object encodable into UTF-8.
                                <para>
                                The following two code snippets are equivalent:
                                </para>
<programlisting><![CDATA[
message = TextMessage("Hey")
]]></programlisting>

<programlisting><![CDATA[
message = TextMessage()
message.text = "Hey"
]]></programlisting>
                                <para>
                                    Here's how to get the content of a message
                                    received by a JmsTemplate.
                                </para>
<programlisting><![CDATA[
# .. skip creating the connection factory and a JmsTemplate

message = jms_template.receive()
print message.text
]]></programlisting>
                            </entry>
 						</row>
						<row>
							<entry>jms_correlation_id</entry>
							<entry>
                                Equivalent to Java's JMSCorrelationID message
                                header. It must be a string
                                instance when set manually - a good way
                                to produce correlation identifiers is to use
                                the Python's <classname>uuid4</classname> type, e.g.:
<programlisting><![CDATA[
# stdlib
from uuid import uuid4

# Spring Python
from springpython.jms.core import TextMessage

# Prapare the JMS correlation ID
jms_correlation_id = uuid4().hex

message = TextMessage("Howdy")
message.jms_correlation_id = jms_correlation_id

# Now the message can be sent with a JMS correlation ID such as 6f5b070bb0ed472bbe63d511776bb1dc
# which is a 128 bits long identifier.
]]></programlisting>
                            </entry>
 						</row>
						<row>
							<entry>jms_delivery_mode</entry>
							<entry>Equivalent to Java's JMSDeliveryMode, can be
                            both read and written to and must be
                            equal to one of the following values 
                            <classname>springpython.jms.DELIVERY_MODE_NON_PERSISTENT</classname>,
                            <classname>springpython.jms.DELIVERY_MODE_PERSISTENT</classname> or
                            <classname>springpython.jms.DEFAULT_DELIVERY_MODE</classname>.
                            The default value - <classname>DEFAULT_DELIVERY_MODE</classname> -
                            equals to
                            <classname>DELIVERY_MODE_PERSISTENT</classname>.
                            </entry>
 						</row>
						<row>
							<entry>jms_destination</entry>
							<entry>
                                Equivalent to Java's JMSDestination, automatically
                                populated by JmsTemplate objects on send
                                or receive time.
                                May be read from but <emphasis>must not be set manually.</emphasis>
                            </entry>
 						</row>
						<row>
							<entry>jms_expiration</entry>
							<entry>
                                Same as Java's JMSExpiration - allow for a message
                                to expire after a certain amount of time.
                                The value is automatically set by JmsTemplate
                                for received messages.
                                For messages being sent the time expressed
                                is in milliseconds, as in the following code:
<programlisting><![CDATA[
message = TextMessage("I will expire in half a second")

# Set the message's expiration time to 500 ms
message.jms_expiration = 500
]]></programlisting>
                            </entry>
 						</row>
						<row>
							<entry>jms_message_id</entry>
							<entry>
                                Same as Java's JMSMessageID. Automatically set
                                by JmsTemplate for received messages, may be
                                set manually but the value will be ignored
                                by the JMS provider.
                            </entry>
 						</row>
						<row>
							<entry>jms_priority</entry>
							<entry>
                                Equivalent to Java's JMSPriority, may be set
                                to an integer value. If not set manually, the
                                value will be automatically computed by the
                                JMS provider. An incoming message will have
                                the value set as given by the JMS provider.
                            </entry>
 						</row>
						<row>
							<entry>jms_redelivered</entry>
							<entry>
                                Same as Java's JMSRedelivered header. Should
                                not be set manually. Default value for incoming
                                messages is <emphasis>False</emphasis>; for messages
                                received from WebSphere MQ (which is currently
                                the only supported JMS provider) it will be
                                <emphasis>True</emphasis> if the underlying
                                MQ message's <emphasis>BackoutCount</emphasis>
                                attribute is 1 or greater.
                            </entry>
 						</row>
						<row>
							<entry>jms_reply_to</entry>
							<entry>
                                Equivalent to Java's JMSReplyTo,
                                the name of a JMS destination to which responses
                                to the currently sent message should be delivered.
<programlisting><![CDATA[
message = TextMessage("Please, reply to me.")

# Set the reply to queue
message.jms_reply_to = "REPLY.TO.QUEUE.1"
]]></programlisting>
                            <para>
                                See <link linkend="jms-jms-template-dynamic-queues">here</link>
                                for an example of how to use
                                <emphasis>jms_reply_to</emphasis> in request/reply
                                scenarios.
                            </para>
                            </entry>
 						</row>
						<row>
							<entry>jms_timestamp</entry>
							<entry>
                                Same as Java's JMSTimestamp, the timestamp
                                of a message returned as a
                                number of milliseconds with
                                a centiseconds precision. Should not be set
                                manually.
                            </entry>
 						</row>
						<row>
							<entry>max_chars_printed</entry>
							<entry>
                                Specifies how many characters of the business
                                payload (the <classname>.text</classname>
                                attribute) will be returned by the TextMessage
                                instance's <classname>__str__</classname> method,
                                which is used, for instance, for logging purposes.
                                Default value is 100 characters.
                            <para>
                                Consider the code below, in both cases the message's
                                content is the same, the messages differ only
                                by the value of the 
                                <classname>max_chars_printed</classname>
                                attribute.
                            </para>
<programlisting><![CDATA[                            
# Spring Python
from springpython.jms.core import TextMessage

payload = "Business payload. " * 8

msg = TextMessage(payload)
msg.max_chars_printed = 50

print msg

# Will show in the console: 
                            
JMS message class: jms_text
  jms_delivery_mode:  2
  jms_expiration:     None
  jms_priority:       None
  jms_message_id:     None
  jms_timestamp:      None
  jms_correlation_id: None
  jms_destination:    None
  jms_reply_to:       None
  jms_redelivered:    None
Business payload. Business payload. Business paylo
Another 94 character(s) omitted
]]></programlisting>

<programlisting><![CDATA[
# Spring Python
from springpython.jms.core import TextMessage

payload = "Business payload. " * 8

msg = TextMessage(payload)
msg.max_chars_printed = 130

print msg

# Will show in the console: 
                            
JMS message class: jms_text
  jms_delivery_mode:  2
  jms_expiration:     None
  jms_priority:       None
  jms_message_id:     None
  jms_timestamp:      None
  jms_correlation_id: None
  jms_destination:    None
  jms_reply_to:       None
  jms_redelivered:    None
Business payload. Business payload. Business payload. Business payload. Business payload. Business payload. Business payload. Busi
Another 14 character(s) omitted
]]></programlisting>
                            </entry>
 						</row>
                    </tbody>
                </tgroup>
            </table>
            
        </para>
        
        <para>
            Attributes shown in the table above are standard JMS headers, available
            regardless of the JMS provider used. For WebSphereMQ - which is currently
            the only JMS provider supported by Spring Python - following attributes
            are also available:
                JMS_IBM_Report_Exception,
                JMS_IBM_Report_Expiration,
                JMS_IBM_Report_COA,
                JMS_IBM_Report_COD,
                JMS_IBM_Report_PAN,
                JMS_IBM_Report_NAN,
                JMS_IBM_Report_Pass_Msg_ID,
                JMS_IBM_Report_Pass_Correl_ID,
                JMS_IBM_Report_Discard_Msg,
                JMSXGroupID,
                JMSXGroupSeq,
                JMS_IBM_Feedback,
                JMS_IBM_Last_Msg_In_Group,
                JMSXUserID,
                JMS_IBM_PutTime,
                JMS_IBM_PutDate and
                JMSXAppID.
                Refer to the IBM's Java JMS documentation for info on how to use them.
        </para>
        
        <para>
            Creating custom JMS properties is simply a matter of assigning
            a value to an attribute, there are no special methods such as
            <methodname>setStringProperty/getStringProperty</methodname>
            which are used in Java JMS, thus the following code will create
            a custom <emphasis>MESSAGE_NAME</emphasis> property which can be
            read by <methodname>getStringProperty</methodname> on the Java side.
        </para>
<programlisting><![CDATA[
# Spring Python
from springpython.jms.core import TextMessage

msg = TextMessage("Hello!")
msg.MESSAGE_NAME = "HelloRequest"
]]></programlisting>

        <para>
            Observe how custom properties will be printed to the console along
            with standard JMS headers:
        </para>
<programlisting><![CDATA[
# Spring Python
from springpython.jms.core import TextMessage

msg = TextMessage("Hello!")
msg.MESSAGE_NAME = "HelloRequest"
msg.CLIENT = "CRM"
msg.CUSTOMER_ID = "201888228"

print msg

# Will show:

JMS message class: jms_text
  jms_delivery_mode:  2
  jms_expiration:     None
  jms_priority:       None
  jms_message_id:     None
  jms_timestamp:      None
  jms_correlation_id: None
  jms_destination:    None
  jms_reply_to:       None
  jms_redelivered:    None
  CLIENT:CRM
  CUSTOMER_ID:201888228
  MESSAGE_NAME:HelloRequest
Hello!
]]></programlisting>

        <para>
            Not all TextMessage's attributes can be set to a custom value,
            the exact list of reserved attributes' names is available
            as <classname>springpython.jms.core.reserved_attributes</classname>.
            There's a very slim chance you'll ever encounter the conflict with
            your application's message attributes, nevertheless be sure to check
            the list before using custom JMS properties in your code.
        </para>
        
    </section>
    
    <section id="jms-exceptions">
        <title>Exceptions</title>
        <para>
            <classname>springpython.jms.JMSException</classname> 
            is the base exception class for all JMS-related issues that may be
            raised by Spring Python's JMS
            and a pair of 
            its specialized subclasses is also available:
            <classname>springpython.jms.NoMessageAvailableException</classname>
            and
            <classname>springpython.jms.WebSphereMQJMSException</classname>.
        </para>
        <para>
            NoMessageAvailableException is raised when a call to 
            <emphasis>receive</emphasis> or <emphasis>receive_and_convert</emphasis>
            timeouts, which indicates that there's no message available for
            a given JMS destination.
        </para>
        <para>
            WebSphereMQJMSException is raised when the underlying error is known
            to be caused by a call to WebSphere MQ API, such as a call to connect
            to a queue manager. Spring Python
            tries to populate these attributes of a WebSphereMQJMSException object
            when an error condition arises:
				<itemizedlist>
					<listitem>
						<emphasis>message</emphasis> -
                        a descriptive information of what has happened; 
                        taken either from an exception raised deeper in a call stack
                        or an explanation from Spring Python itself,
					</listitem>
					<listitem>
						<emphasis>completion_code</emphasis> -
                        an integer code returned by the call a queue manager,
                        may be either 1 (a warning) or 2 (an error), it's known
                        as an MQCC in WebSphere MQ,
					</listitem>
					<listitem>
						<emphasis>reason_code</emphasis> - 
                        an integer code, as returned by the queue manager,
                        giving a reason for the failure, known as MQRC in
                        WebSphere MQ lingo. The meaning may be looked up
                        in the IBM's "WebSphere MQ Constants" manual.
					</listitem>
                </itemizedlist>
            <para>
                Note that <emphasis>message</emphasis>,
                    <emphasis>completion_code</emphasis> and
                    <emphasis>reason_code</emphasis> are all optional and there's
                    no guarantee they will be actually returned.
                    Should you caught a WebSphereMQJMSException,
                    you should always check for their existence before making
                    any use of them.
            </para>
        </para>
    </section>
    
    <section id="jms-logging-and-troubleshooting">
        <title>Logging and troubleshooting</title>
        
        <para>
            Spring Python's JMS uses standard Python's 
            <classname>logging</classname> module for emitting
            the messages. In general, you can expect JMS to behave sane, it won't
            overflow your logs with meaningless entries, e.g. if you configure it
            to log the messages at the <classname>ERROR</classname> level then
            you'll be notified of only truly erratic situtations. 
        </para>
        
        <para>
            In addition to <classname>logging</classname>'s builtin levels,
            JMS uses one custom level - 
            <classname>springpython.util.TRACE1</classname>, 
            <emphasis>enabling TRACE1 will degrade the performance considerably</emphasis>
            and will result in a huge number of messages written to the logs. 
            Use it sparingly at troubleshooting times when you'd like to see
            the exact flow of messages, raw bytes and JMS headers passing by
            the Spring Python's JMS classes involved. Do not ever enable it in production
            environments unless you have a very compelling reason and you're
            sure you're comfortable with paying the performance penalty.
            Consider using the <classname>logging.DEBUG</classname>
            level instead of <classname>TRACE1</classname> if all you're after
            is simply seeing the messages' payload.
        </para>
        
        <para>
            The only JMS logger currently employed by Spring Python is
            <classname>springpython.jms.factory.WebSphereMQConnectionFactory</classname>
            and here's how it can be configured to work at the 
            <classname>INFO</classname> level:
        </para>
        
<programlisting><![CDATA[

# stdlib
import logging

log_format = "%(asctime)s - %(levelname)s - %(process)d - %(threadName)s - %(name)s - %(message)s"
formatter = logging.Formatter(log_format)

handler = logging.StreamHandler()
handler.setFormatter(formatter)

jms_logger = logging.getLogger("springpython.jms.factory.WebSphereMQConnectionFactory")

jms_logger.setLevel(level=logging.INFO)
jms_logger.addHandler(handler)
]]></programlisting>

        <para>
            Here's how to configure it to log messages at the
            <classname>TRACE1</classname> level:
        </para>
        
<programlisting><![CDATA[

# stdlib
import logging

# Spring Python
from springpython.util import TRACE1

log_format = "%(asctime)s - %(levelname)s - %(process)d - %(threadName)s - %(name)s - %(message)s"
formatter = logging.Formatter(log_format)

handler = logging.StreamHandler()
handler.setFormatter(formatter)

jms_logger = logging.getLogger("springpython.jms.factory.WebSphereMQConnectionFactory")

jms_logger.setLevel(level=TRACE1)
jms_logger.addHandler(handler)
]]></programlisting>

        <para>
            How much information is being logged depends on the logging level, the 
            average message size, the messages'
            <classname>max_chars_printed</classname> attribute value and the
            message rate.
        </para>
        <para>
            Here's an estimation
            of how fast log files will grow depending on the logging level.
            During the test, the message size was 5kB, there were a total of 10,000 messages
            sent, the <classname>max_chars_printed</classname> attribute had
            value of 100 and the log entries were written to an ordinary log file.
        </para>
        <para>
            <itemizedlist>
                <listitem>
                    <classname>ERROR</classname> - 0KB, no errors were 
                        encountered thus no entries were written to the log file,
                </listitem>
                    
                <listitem>
                    <classname>INFO</classname> - 0.9KB, only very basic info was
                    logged, such as events of connecting to and disconnecting
                    from a JMS provider,
                </listitem>
                
                <listitem>
                    <classname>DEBUG</classname> - 7,3MB, up to the 
                    <classname>max_chars_printed</classname> characters of 
                    each message were written to the file plus all of JMS headers
                    and some additional info as well,
                </listitem>
                
                <listitem>
                    <classname>TRACE1</classname> - 79MB, full trace was taken
                    which resulted in the log file's growing
                    <emphasis>tenfold</emphasis> as compared to the 
                    <classname>DEBUG</classname> level.
                </listitem>
            </itemizedlist>
        </para>
        
    </section>
	
</chapter>
